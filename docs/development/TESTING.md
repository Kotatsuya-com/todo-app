# ãƒ†ã‚¹ãƒˆã‚¬ã‚¤ãƒ‰

## ğŸ§ª ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

Clean Architectureãƒ‘ã‚¿ãƒ¼ãƒ³ã«åŸºã¥ã„ãŸåŠ¹ç‡çš„ãªãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã‚’æ¡ç”¨ã—ã€ä¿å®ˆæ€§ã¨ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£ã‚’é‡è¦–ã—ãŸãƒ†ã‚¹ãƒˆå®Ÿè£…ã‚’è¡Œã„ã¾ã™ã€‚

**ğŸ‰ 2025å¹´8æœˆ: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ»ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å®Œå…¨å¯¾å¿œ**

## ğŸ¯ ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®å„ªå…ˆé †ä½

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆ

#### 1. Serviceå±¤ï¼ˆæœ€é‡è¦ï¼‰
**ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã®å˜ä½“ãƒ†ã‚¹ãƒˆ**
- è¤‡é›‘ãªãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ã®æ¤œè¨¼
- å¤–éƒ¨APIé€£æºã®å‹•ä½œç¢ºèª
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®æ¤œè¨¼

#### 2. Repositoryå±¤
**ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã®ãƒ†ã‚¹ãƒˆ**
- CRUDæ“ä½œã®å‹•ä½œç¢ºèª
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®æ¤œè¨¼
- ãƒ‡ãƒ¼ã‚¿å¤‰æ›ã®æ­£ç¢ºæ€§

#### 3. Entityå±¤
**ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆ**
- ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ã®æ¤œè¨¼
- çŠ¶æ…‹å¤‰æ›´ã®æ­£ç¢ºæ€§
- ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½

#### 4. APIå±¤
**çµ±åˆãƒ†ã‚¹ãƒˆï¼ˆServiceå±¤ãƒ¢ãƒƒã‚¯ä½¿ç”¨ï¼‰**
- HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®æ¤œè¨¼
- èªè¨¼ãƒ»èªå¯ã®å‹•ä½œç¢ºèª
- ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®æ¤œè¨¼

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆ

#### 1. Use Caseså±¤ï¼ˆæœ€é‡è¦ï¼‰
**ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã®å˜ä½“ãƒ†ã‚¹ãƒˆ**
- ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã®å‹•ä½œç¢ºèª
- Repositoryå±¤ã¨ã®é€£æºãƒ†ã‚¹ãƒˆ
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®æ¤œè¨¼

#### 2. Repositoryå±¤
**ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹å®Ÿè£…ã®ãƒ†ã‚¹ãƒˆ**
- Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã®é€£æº
- ãƒ‡ãƒ¼ã‚¿å¤‰æ›ã®æ­£ç¢ºæ€§
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®æ¤œè¨¼

#### 3. Entityå±¤
**ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®ãƒ†ã‚¹ãƒˆ**
- ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ã®æ¤œè¨¼
- ãƒ‡ãƒ¼ã‚¿å¤‰æ›ã®æ­£ç¢ºæ€§
- ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½

#### 4. Presentationå±¤ï¼ˆã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ï¼‰
**UIè«–ç†ã®çµ±åˆãƒ†ã‚¹ãƒˆ**
- ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ã®å‹•ä½œç¢ºèª
- Use Caseså±¤ã¨ã®é€£æºãƒ†ã‚¹ãƒˆ
- çŠ¶æ…‹ç®¡ç†ã®æ¤œè¨¼

## ğŸ” ãƒ†ã‚¹ãƒˆå“è³ªä¿è¨¼ï¼ˆMANDATORYï¼‰

### ãƒ†ã‚¹ãƒˆä¿®æ­£æ™‚ã®å¿…é ˆãƒ—ãƒ­ã‚»ã‚¹

**ğŸš¨ ãƒ†ã‚¹ãƒˆä¿®æ­£ãƒ»è¿½åŠ å¾Œã¯å¿…ãš`npm run quality-check`ã§å“è³ªä¿è¨¼**

#### 1. ãƒ†ã‚¹ãƒˆå¤±æ•—æ™‚ã®æ®µéšçš„åˆ†æ
```bash
# ãƒ†ã‚¹ãƒˆå˜ä½“å®Ÿè¡Œã§å•é¡Œã®ç‰¹å®š
npm run test:node    # Backendå±¤ãƒ†ã‚¹ãƒˆ
npm run test:browser # Frontendå±¤ãƒ†ã‚¹ãƒˆ

# å“è³ªãƒã‚§ãƒƒã‚¯å…¨ä½“ã®å®Ÿè¡Œ
npm run quality-check # lint + type-check + build + test
```

#### 2. Repositoryå±¤ãƒ†ã‚¹ãƒˆå¤±æ•—å¯¾å¿œ
- **Mock vs å®Ÿè£…ã®æ•´åˆæ€§ç¢ºèª**
  - Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ãƒã‚§ãƒ¼ãƒ³
  - æˆ»ã‚Šå€¤ã®å‹ã¨null/undefinedå‡¦ç†
  - ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®æ§‹é€ 

```typescript
// âœ… é©åˆ‡ãªSupabaseãƒ¢ãƒƒã‚¯è¨­è¨ˆ
const mockFromResult = {
  select: jest.fn().mockReturnThis(),
  eq: jest.fn().mockResolvedValue({ data: mockData, error: null })
}

// âŒ ä¸é©åˆ‡ãªãƒã‚§ãƒ¼ãƒ³è¨­è¨ˆ  
const mockFromResult = {
  select: jest.fn().mockResolvedValue({ data: mockData, error: null })
  // eq()ãŒå‘¼ã°ã‚Œã‚‹ã®ã«è¨­å®šã•ã‚Œã¦ã„ãªã„
}
```

#### 3. Serviceå±¤ãƒ†ã‚¹ãƒˆå“è³ªç¢ºèª
- **ä¾å­˜æ€§æ³¨å…¥ã®é©åˆ‡æ€§**: Repository interfacesä½¿ç”¨
- **Mockçµæœè¨­å®š**: setMockResults() ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ´»ç”¨
- **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: æˆåŠŸãƒ»å¤±æ•—ä¸¡ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒ†ã‚¹ãƒˆ

#### 4. ãƒ†ã‚¹ãƒˆ vs å®Ÿè£…ã®å•é¡Œåˆ¤æ–­
1. **å®Ÿè£…ã‚³ãƒ¼ãƒ‰ã‚’å…ˆã«ç¢ºèª** (`lib/repositories/`, `lib/services/`)
2. **ãƒ†ã‚¹ãƒˆæœŸå¾…å€¤ã¨å®Ÿè£…å‹•ä½œã®æ¯”è¼ƒ**
3. **100%ãŒãƒ†ã‚¹ãƒˆå•é¡Œã®å ´åˆ**: Mockãƒ»æœŸå¾…å€¤ã®ä¿®æ­£
4. **å®Ÿè£…å•é¡Œã®å ´åˆ**: ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯è¦ä»¶ã®å†ç¢ºèª

### å“è³ªãƒã‚§ãƒƒã‚¯çµ±åˆãƒ‘ã‚¿ãƒ¼ãƒ³

```bash
# é–‹ç™ºãƒ•ãƒ­ãƒ¼ä¾‹
vim lib/repositories/TodoRepository.ts  # å®Ÿè£…ä¿®æ­£
npm run test:node -- TodoRepository     # å€‹åˆ¥ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm run quality-check                   # æœ€çµ‚å“è³ªç¢ºèª
git add . && git commit                 # æˆåŠŸå¾Œã®ã‚³ãƒŸãƒƒãƒˆ
```

## ğŸ“ ãƒ†ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆä¾‹

#### Serviceå±¤ãƒ†ã‚¹ãƒˆä¾‹

```typescript
// __tests__/lib/services/SlackService.test.ts
import { SlackService } from '@/lib/services/SlackService'
import { MockSlackRepository } from '@/__tests__/mocks/repositories'
import { MockTodoRepository } from '@/__tests__/mocks/repositories'

describe('SlackService', () => {
  let slackService: SlackService
  let mockSlackRepo: MockSlackRepository
  let mockTodoRepo: MockTodoRepository

  beforeEach(() => {
    mockSlackRepo = new MockSlackRepository()
    mockTodoRepo = new MockTodoRepository()
    slackService = new SlackService(mockSlackRepo, mockTodoRepo)
  })

  describe('processWebhookEvent', () => {
    test('should process valid webhook event successfully', async () => {
      // Arrange
      const webhookId = 'test-webhook-id'
      const payload = createMockSlackPayload()
      
      mockSlackRepo.setMockResults([
        { success: true, data: createMockWebhook() },
        { success: true, data: createMockConnection() }
      ])
      
      mockTodoRepo.setMockResults([
        { success: true, data: createMockTodo() }
      ])

      // Act
      const result = await slackService.processWebhookEvent(webhookId, payload)

      // Assert
      expect(result.success).toBe(true)
      expect(result.statusCode).toBe(200)
      expect(result.data).toBeDefined()
    })

    test('should return 404 when webhook not found', async () => {
      // Arrange
      const webhookId = 'non-existent-webhook'
      const payload = createMockSlackPayload()
      
      mockSlackRepo.setMockResults([
        { success: false, error: 'Webhook not found' }
      ])

      // Act
      const result = await slackService.processWebhookEvent(webhookId, payload)

      // Assert
      expect(result.success).toBe(false)
      expect(result.statusCode).toBe(404)
      expect(result.error).toBe('Webhook not found')
    })
  })
})
```

#### Entityå±¤ãƒ†ã‚¹ãƒˆä¾‹

```typescript
// __tests__/lib/entities/Todo.test.ts
import { TodoEntity } from '@/lib/entities/Todo'
import { createMockTodo } from '@/__tests__/fixtures/entities'

describe('TodoEntity', () => {
  describe('getQuadrant', () => {
    test('should return urgent_important for urgent and important task', () => {
      // Arrange
      const todoData = createMockTodo({
        deadline: new Date().toISOString().split('T')[0], // Today
        importance_score: 0.8
      })
      const todo = new TodoEntity(todoData)

      // Act
      const quadrant = todo.getQuadrant()

      // Assert
      expect(quadrant).toBe('urgent_important')
    })

    test('should return not_urgent_important for future important task', () => {
      // Arrange
      const futureDate = new Date()
      futureDate.setDate(futureDate.getDate() + 7)
      
      const todoData = createMockTodo({
        deadline: futureDate.toISOString().split('T')[0],
        importance_score: 0.8
      })
      const todo = new TodoEntity(todoData)

      // Act
      const quadrant = todo.getQuadrant()

      // Assert
      expect(quadrant).toBe('not_urgent_important')
    })
  })

  describe('isUrgent', () => {
    test('should return true for task with deadline today or past', () => {
      // Arrange
      const todoData = createMockTodo({
        deadline: new Date().toISOString().split('T')[0]
      })
      const todo = new TodoEntity(todoData)

      // Act
      const isUrgent = todo.isUrgent()

      // Assert
      expect(isUrgent).toBe(true)
    })

    test('should return false for task without deadline', () => {
      // Arrange
      const todoData = createMockTodo({ deadline: null })
      const todo = new TodoEntity(todoData)

      // Act
      const isUrgent = todo.isUrgent()

      // Assert
      expect(isUrgent).toBe(false)
    })
  })

  describe('isImportant', () => {
    test('should return true for high importance score', () => {
      // Arrange
      const todoData = createMockTodo({ importance_score: 0.8 })
      const todo = new TodoEntity(todoData)

      // Act
      const isImportant = todo.isImportant()

      // Assert
      expect(isImportant).toBe(true)
    })

    test('should return false for low importance score', () => {
      // Arrange
      const todoData = createMockTodo({ importance_score: 0.2 })
      const todo = new TodoEntity(todoData)

      // Act
      const isImportant = todo.isImportant()

      // Assert
      expect(isImportant).toBe(false)
    })
  })
})
```

#### APIå±¤ãƒ†ã‚¹ãƒˆä¾‹

```typescript
// __tests__/api/slack/events/user/[webhook_id]/route.test.ts
import { POST } from '@/app/api/slack/events/user/[webhook_id]/route'
import { NextRequest } from 'next/server'
import { MockSlackService } from '@/__tests__/mocks/services'

// Serviceå±¤ã®ãƒ¢ãƒƒã‚¯
jest.mock('@/lib/services/ServiceFactory', () => ({
  createServices: () => ({
    slackService: new MockSlackService()
  })
}))

describe('/api/slack/events/user/[webhook_id]', () => {
  let mockSlackService: MockSlackService

  beforeEach(() => {
    const { slackService } = require('@/lib/services/ServiceFactory').createServices()
    mockSlackService = slackService
  })

  test('should process valid webhook event', async () => {
    // Arrange
    const webhookId = 'test-webhook-id'
    const payload = createMockSlackPayload()
    
    mockSlackService.setMockResults([
      { success: true, data: { message: 'Event processed' }, statusCode: 200 }
    ])

    const request = new NextRequest('http://localhost:3000/api/slack/events/user/' + webhookId, {
      method: 'POST',
      body: JSON.stringify(payload),
      headers: { 'Content-Type': 'application/json' }
    })

    // Act
    const response = await POST(request, { params: { webhook_id: webhookId } })
    const responseBody = await response.json()

    // Assert
    expect(response.status).toBe(200)
    expect(responseBody.message).toBe('Event processed')
  })

  test('should return 404 for non-existent webhook', async () => {
    // Arrange
    const webhookId = 'non-existent-webhook'
    const payload = createMockSlackPayload()
    
    mockSlackService.setMockResults([
      { success: false, error: 'Webhook not found', statusCode: 404 }
    ])

    const request = new NextRequest('http://localhost:3000/api/slack/events/user/' + webhookId, {
      method: 'POST',
      body: JSON.stringify(payload)
    })

    // Act
    const response = await POST(request, { params: { webhook_id: webhookId } })
    const responseBody = await response.json()

    // Assert
    expect(response.status).toBe(404)
    expect(responseBody.error).toBe('Webhook not found')
  })
})
```

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆä¾‹

#### Use Caseså±¤ãƒ†ã‚¹ãƒˆä¾‹

```typescript
// __tests__/src/domain/use-cases/TodoUseCases.test.ts
import { TodoUseCases } from '@/src/domain/use-cases/TodoUseCases'
import { MockTodoRepository } from '@/__tests__/mocks/repositories'

describe('TodoUseCases', () => {
  let todoUseCases: TodoUseCases
  let mockTodoRepo: MockTodoRepository

  beforeEach(() => {
    mockTodoRepo = new MockTodoRepository()
    todoUseCases = new TodoUseCases(mockTodoRepo)
  })

  describe('createTodo', () => {
    test('should create todo successfully', async () => {
      // Arrange
      const params = {
        userId: 'user-123',
        title: 'Test Todo',
        body: 'Test description',
        deadline: '2025-12-31'
      }
      
      mockTodoRepo.setMockResults([
        { success: true, data: createMockTodoEntity() }
      ])

      // Act
      const result = await todoUseCases.createTodo(params)

      // Assert
      expect(result.success).toBe(true)
      expect(result.data).toBeDefined()
    })
  })
})
```

#### Repositoryå±¤ãƒ†ã‚¹ãƒˆä¾‹

```typescript
// __tests__/src/infrastructure/repositories/SupabaseTodoRepository.test.ts
import { SupabaseTodoRepository } from '@/src/infrastructure/repositories/SupabaseTodoRepository'
import { createMockSupabaseClient } from '@/__tests__/mocks/supabase'

describe('SupabaseTodoRepository', () => {
  let repository: SupabaseTodoRepository
  let mockSupabase: any

  beforeEach(() => {
    mockSupabase = createMockSupabaseClient()
    repository = new SupabaseTodoRepository(mockSupabase)
  })

  describe('findById', () => {
    test('should return todo when found', async () => {
      // Arrange
      const todoId = 'todo-123'
      mockSupabase.from.mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            single: jest.fn().mockResolvedValue({
              data: createMockTodoData(),
              error: null
            })
          })
        })
      })

      // Act
      const result = await repository.findById(todoId)

      // Assert
      expect(result.success).toBe(true)
      expect(result.data).toBeInstanceOf(TodoEntity)
    })
  })
})
```

#### ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ãƒ†ã‚¹ãƒˆä¾‹

```typescript
// __tests__/src/presentation/hooks/useAuth.test.ts
import { renderHook, act } from '@testing-library/react'
import { useAuth } from '@/src/presentation/hooks/useAuth'
import { MockAuthUseCases } from '@/__tests__/mocks/use-cases'

// Use Caseså±¤ã®ãƒ¢ãƒƒã‚¯
jest.mock('@/src/infrastructure/di/ServiceFactory', () => ({
  createAuthUseCases: () => new MockAuthUseCases()
}))

describe('useAuth', () => {
  let mockAuthUseCases: MockAuthUseCases

  beforeEach(() => {
    const { createAuthUseCases } = require('@/src/infrastructure/di/ServiceFactory')
    mockAuthUseCases = createAuthUseCases()
  })

  test('should handle user login successfully', async () => {
    // Arrange
    mockAuthUseCases.setMockResults([
      { success: true, data: createMockUserEntity() }
    ])

    const { result } = renderHook(() => useAuth())

    // Act
    await act(async () => {
      const loginResult = await result.current.login('test@example.com', 'password')
      expect(loginResult.success).toBe(true)
    })

    // Assert
    expect(result.current.user).toBeDefined()
    expect(result.current.loading).toBe(false)
  })
})
```

## ğŸ”§ Jestè¨­å®šã®åˆ†é›¢

### ç’°å¢ƒåˆ¥Jestè¨­å®šï¼ˆ2025å¹´8æœˆå®Ÿè£…ï¼‰

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯2ã¤ã®Jestè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ†ã‚¹ãƒˆã‚’é©åˆ‡ãªç’°å¢ƒã§å®Ÿè¡Œã—ã¦ã„ã¾ã™ï¼š

#### jest.config.js - Browserç’°å¢ƒ
- **å¯¾è±¡**: `api/`, `src/`ä»¥ä¸‹ã®ãƒ†ã‚¹ãƒˆ
- **ç’°å¢ƒ**: `jest-environment-jsdom`
- **ç”¨é€”**: React/Next.jsçµ±åˆãƒ†ã‚¹ãƒˆã€APIãƒ«ãƒ¼ãƒˆãƒ†ã‚¹ãƒˆ
- **ãƒ†ã‚¹ãƒˆæ•°**: ç´„280ãƒ†ã‚¹ãƒˆ

#### jest.node.config.js - Node.jsç’°å¢ƒ  
- **å¯¾è±¡**: `lib/`ä»¥ä¸‹ã®ãƒ†ã‚¹ãƒˆ
- **ç’°å¢ƒ**: `node`
- **ç”¨é€”**: ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã€ã‚µãƒ¼ãƒ“ã‚¹å±¤ã€ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
- **ãƒ†ã‚¹ãƒˆæ•°**: ç´„872ãƒ†ã‚¹ãƒˆ

#### ãªãœåˆ†é›¢ã™ã‚‹ã‹ï¼Ÿ
1. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: lib/ä»¥ä¸‹ã¯Next.jséä¾å­˜ã®ãŸã‚ã€è»½é‡ãªNodeç’°å¢ƒã§é«˜é€Ÿå®Ÿè¡Œ
2. **é©åˆ‡ãªç’°å¢ƒ**: UIãƒ†ã‚¹ãƒˆã¯DOMç’°å¢ƒã€ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã¯ç´”ç²‹ãªNodeç’°å¢ƒ
3. **ä¾å­˜é–¢ä¿‚ã®æ˜ç¢ºåŒ–**: å„å±¤ãŒå¿…è¦ã¨ã™ã‚‹ç’°å¢ƒã‚’æ˜ç¤ºçš„ã«åˆ†é›¢

#### å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰
```bash
npm run test           # ä¸¡ç’°å¢ƒã§å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm run test:node      # Nodeç’°å¢ƒã®ã¿ï¼ˆlib/ï¼‰
npm run test:browser   # Browserç’°å¢ƒã®ã¿ï¼ˆapi/, src/ï¼‰
```

## ğŸ”§ ãƒ¢ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ 

### jest-mock-extended ã¨ createAutoMock ã®ä½¿ã„åˆ†ã‘æˆ¦ç•¥

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ç”¨é€”ã«å¿œã˜ã¦2ã¤ã®ãƒ¢ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ ã‚’åŠ¹æœçš„ã«ä½¿ã„åˆ†ã‘ã¦ã„ã¾ã™ï¼š

#### 1. jest-mock-extended (Interface Mockingæ¨å¥¨)
- **ç”¨é€”**: Repository/Service ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®å‹å®‰å…¨ãªãƒ¢ãƒƒã‚¯ç”Ÿæˆ
- **é©ç”¨å ´é¢**: å€‹åˆ¥ãƒ¡ã‚½ãƒƒãƒ‰ãƒ¢ãƒƒã‚¯ã€å¼•æ•°åˆ¥ãƒ¢ãƒƒã‚¯ã€Deep Mocking
- **åˆ©ç‚¹**: ts-jest 29å®Œå…¨äº’æ›ã€å®Œå…¨ãªå‹å®‰å…¨æ€§ã€å¼•æ•°åˆ¥ãƒ¬ã‚¹ãƒãƒ³ã‚¹å¯¾å¿œ
- **ç’°å¢ƒ**: Node.jsã€Browserä¸¡ç’°å¢ƒã§å‹•ä½œ

```typescript
// Repository Interface mocking
import { mock, MockProxy } from 'jest-mock-extended'

let mockRepo: MockProxy<SlackRepositoryInterface> = mock<SlackRepositoryInterface>()

// Individual method mocking
mockRepo.findById.mockResolvedValue({ success: true, data: entity })

// Argument-specific mocking
mockRepo.findById.calledWith('id-1').mockResolvedValue(result1)
mockRepo.findById.calledWith('id-2').mockResolvedValue(result2)

// Sequential calls with mockReturnValueOnce
mockRepo.create
  .mockResolvedValueOnce({ success: true, data: result1 })
  .mockResolvedValueOnce({ success: false, error: 'Duplicate' })
```

#### 2. createAutoMock (Sequential Results APIæ¨å¥¨)
- **ç”¨é€”**: APIçµ±åˆãƒ†ã‚¹ãƒˆã€è¤‡æ•°å‘¼ã³å‡ºã—ã§ã®é †æ¬¡ãƒ¬ã‚¹ãƒãƒ³ã‚¹
- **é©ç”¨å ´é¢**: setMockResults APIã«ã‚ˆã‚‹çµæœã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã€Proxy-basedè‡ªå‹•ç”Ÿæˆ
- **åˆ©ç‚¹**: Sequential Results APIã€ç°¡æ½”ãªè¤‡æ•°ãƒ¬ã‚¹ãƒãƒ³ã‚¹è¨­å®š
- **ç‰¹åŒ–ç”¨é€”**: APIçµ±åˆãƒ†ã‚¹ãƒˆã€Serviceå±¤ã®è¤‡é›‘ãªãƒ•ãƒ­ãƒ¼

```typescript
// Sequential Results API
import { createAutoMock } from '@/__tests__/utils/autoMock'

let mockService = createAutoMock<SlackServiceInterface>()

// Set sequential responses
mockService.setMockResults([
  { success: true, data: result1, statusCode: 200 },
  { success: true, data: result2, statusCode: 200 },
  { success: false, error: 'Not found', statusCode: 404 }
])

// Each call returns the next result in sequence
await mockService.processEvent(payload1)  // â†’ result1
await mockService.processEvent(payload2)  // â†’ result2  
await mockService.processEvent(payload3)  // â†’ error
```

#### ä½¿ã„åˆ†ã‘ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

| ç”¨é€” | æ¨å¥¨æ‰‹æ³• | ç†ç”± |
|------|---------|------|
| Repository Interface | jest-mock-extended | å‹å®‰å…¨æ€§ã€å¼•æ•°åˆ¥ãƒ¢ãƒƒã‚¯ |
| Service Interfaceï¼ˆå€‹åˆ¥ï¼‰ | jest-mock-extended | ãƒ¡ã‚½ãƒƒãƒ‰åˆ¥ã®ç´°ã‹ã„åˆ¶å¾¡ |
| APIçµ±åˆãƒ†ã‚¹ãƒˆ | createAutoMock | Sequential Results API |
| è¤‡æ•°ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ | createAutoMock | setMockResults API |
| å¼•æ•°ä¾å­˜ãƒ†ã‚¹ãƒˆ | jest-mock-extended | calledWith API |
| Deep Mocking | jest-mock-extended | mockDeepå¯¾å¿œ |

### Sequential Results API ã®è©³ç´°ãƒ‘ã‚¿ãƒ¼ãƒ³

#### åŸºæœ¬çš„ãªä½¿ç”¨ä¾‹

```typescript
// åŸºæœ¬çš„ãªSequential Results
const mockService = createAutoMock<SlackServiceInterface>()
mockService.setMockResults([
  { success: true, data: 'First call result' },
  { success: true, data: 'Second call result' },
  { success: false, error: 'Third call fails' }
])

// é †æ¬¡å‘¼ã³å‡ºã—
const result1 = await mockService.someMethod()  // success: true, data: 'First call result'
const result2 = await mockService.someMethod()  // success: true, data: 'Second call result'  
const result3 = await mockService.someMethod()  // success: false, error: 'Third call fails'
const result4 = await mockService.someMethod()  // success: false, error: 'Third call fails' (æœ€å¾Œã®çµæœã‚’ç¶™ç¶š)
```

#### APIçµ±åˆãƒ†ã‚¹ãƒˆã§ã®æ´»ç”¨ä¾‹

```typescript
// APIçµ±åˆãƒ†ã‚¹ãƒˆä¾‹ï¼ˆSlack Eventså‡¦ç†ï¼‰
describe('POST /api/slack/events/user/[webhook_id]', () => {
  let mockSlackService: MockSlackService

  beforeEach(() => {
    mockSlackService = new MockSlackService()
  })

  it('should handle multiple event processing', async () => {
    // è¤‡æ•°ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’é †æ¬¡è¨­å®š
    mockSlackService.setMockResults([
      eventQueuedResponse(),           // 1å›ç›®: ã‚¤ãƒ™ãƒ³ãƒˆå—ä»˜
      webhookNotFoundResponse(),       // 2å›ç›®: Webhookæœªç™ºè¦‹
      userMismatchResponse(),          // 3å›ç›®: ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸ä¸€è‡´
      eventProcessedResponse()         // 4å›ç›®ä»¥é™: æ­£å¸¸å‡¦ç†
    ])

    // é †æ¬¡å‘¼ã³å‡ºã—ãƒ†ã‚¹ãƒˆ
    const response1 = await POST(createRequest(validPayload), { params: { webhook_id } })
    expect(response1.status).toBe(200)  // eventQueued
    
    const response2 = await POST(createRequest(validPayload), { params: { webhook_id } })  
    expect(response2.status).toBe(404)  // webhookNotFound
    
    const response3 = await POST(createRequest(validPayload), { params: { webhook_id } })
    expect(response3.status).toBe(400)  // userMismatch
    
    const response4 = await POST(createRequest(validPayload), { params: { webhook_id } })
    expect(response4.status).toBe(200)  // eventProcessed (ä»¥é™ç¶™ç¶š)
  })
})
```

#### Repositoryå±¤ã§ã®ä½¿ç”¨ä¾‹

```typescript
// Repositoryå±¤ã§ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆ
it('should handle sequential repository failures', async () => {
  const mockRepo = createAutoMock<SlackRepositoryInterface>()
  mockRepo.setMockResults([
    mockResult.success(validConnection),        // 1å›ç›®æˆåŠŸ
    mockResult.error('Database timeout'),       // 2å›ç›®DB ã‚¨ãƒ©ãƒ¼  
    mockResult.error('Connection lost'),        // 3å›ç›®æ¥ç¶šã‚¨ãƒ©ãƒ¼
    mockResult.success(fallbackConnection)      // 4å›ç›®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æˆåŠŸ
  ])
  
  const service = new SlackConnectionService(mockRepo)
  
  // æ®µéšçš„ãªéšœå®³ãƒ†ã‚¹ãƒˆ
  const result1 = await service.getConnection('user-1')
  expect(result1.success).toBe(true)
  
  const result2 = await service.getConnection('user-1')  
  expect(result2.error).toContain('Database timeout')
  
  const result3 = await service.getConnection('user-1')
  expect(result3.error).toContain('Connection lost')
  
  const result4 = await service.getConnection('user-1')
  expect(result4.data).toEqual(fallbackConnection)
})
```

#### åˆ¶é™äº‹é …ã¨æ³¨æ„ç‚¹

1. **çµæœã®æ¶ˆè²»**: setMockResultsé…åˆ—ã®æœ€å¾Œã®è¦ç´ ãŒç„¡é™ã«è¿”ã•ã‚Œã‚‹
2. **å‘¼ã³å‡ºã—é †åº**: ãƒ¡ã‚½ãƒƒãƒ‰åã«é–¢ä¿‚ãªãã€å‘¼ã³å‡ºã—é †ã§resultãŒæ¶ˆè²»ã•ã‚Œã‚‹  
3. **ãƒªã‚»ãƒƒãƒˆ**: æ–°ã—ãsetMockResultsã‚’å‘¼ã¶ã¨ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹

```typescript
// æ³¨æ„: å…¨ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—ã§åŒã˜resulté…åˆ—ã‚’å…±æœ‰
mockService.setMockResults([result1, result2])

await mockService.methodA()  // â†’ result1ãŒè¿”ã•ã‚Œã‚‹
await mockService.methodB()  // â†’ result2ãŒè¿”ã•ã‚Œã‚‹  
await mockService.methodA()  // â†’ result2ãŒè¿”ã•ã‚Œã‚‹ï¼ˆæœ€å¾Œã®è¦ç´ ã‚’ç¶™ç¶šï¼‰
```

#### Proxy-Based autoMock Pattern

```typescript
// __tests__/utils/mockBuilder.ts
export function createAutoMock<T>(): T & MockControlInterface {
  const mockResults: any[] = []
  let callIndex = 0

  const proxy = new Proxy({} as T & MockControlInterface, {
    get(target, prop) {
      if (prop === 'setMockResults') {
        return (results: any[]) => {
          mockResults.length = 0
          mockResults.push(...results)
          callIndex = 0
        }
      }
      
      if (prop === 'getNextResult') {
        return () => {
          if (callIndex >= mockResults.length) {
            throw new Error('No more mock results available')
          }
          return mockResults[callIndex++]
        }
      }
      
      // ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è‡ªå‹•çš„ã«ãƒ¢ãƒƒã‚¯åŒ–
      return jest.fn().mockImplementation(() => {
        return proxy.getNextResult()
      })
    }
  })

  return proxy
}
```

#### Migration Success Examples

**Before: Manual Mock Implementation (606 lines)**
```typescript
class MockNotificationSettingsRepository implements NotificationSettingsRepositoryInterface {
  private results: RepositoryResult<any>[] = []
  private currentIndex = 0

  setResults(results: RepositoryResult<any>[]) {
    this.results = results
    this.currentIndex = 0
  }

  async findByUserId(userId: string): Promise<RepositoryResult<NotificationSettingsEntity | null>> {
    return this.getNextResult()
  }

  async create(settings: NotificationSettingsData): Promise<RepositoryResult<NotificationSettingsEntity>> {
    return this.getNextResult()
  }
  
  // ... 15+ methods with identical implementation
  
  private getNextResult(): RepositoryResult<any> {
    if (this.currentIndex >= this.results.length) {
      throw new Error('No more mock results available')
    }
    return this.results[this.currentIndex++]
  }
}
```

**After: jest-mock-extended Implementation**
```typescript
// Simple one-line mock creation with full type safety
import { mock, MockProxy } from 'jest-mock-extended'

let mockRepository: MockProxy<NotificationSettingsRepositoryInterface>

beforeEach(() => {
  mockRepository = mock<NotificationSettingsRepositoryInterface>()
  service = new NotificationSettingsService(mockRepository)
})

test('should find notification settings by user ID', async () => {
  // Type-safe method mocking
  mockRepository.findByUserId.mockResolvedValue(
    { success: true, data: createMockNotificationSettingsEntity() }
  )

  const result = await service.findByUserId('user-123')
  expect(result.success).toBe(true)
})
```

### Result-Based Mocking

å¾“æ¥ã®è¤‡é›‘ãªmockãƒã‚§ãƒ¼ãƒ³ã‚’ç°¡æ½”ãªçµæœãƒ™ãƒ¼ã‚¹ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ç½®ãæ›ãˆï¼š

```typescript
// âœ… Type-safe approach with jest-mock-extended
import { mock, MockProxy } from 'jest-mock-extended'

const mockService: MockProxy<SlackServiceInterface> = mock<SlackServiceInterface>()
mockService.processWebhookEvent.mockResolvedValueOnce({ success: true, data: result1, statusCode: 200 })
mockService.processWebhookEvent.mockResolvedValueOnce({ success: false, error: 'Not found', statusCode: 404 })

// âœ… Alternative: Proxy-Based autoMock for sequential results
const mockService = createAutoMock<SlackServiceInterface>()
mockService.setMockResults([
  { success: true, data: result1, statusCode: 200 },
  { success: false, error: 'Not found', statusCode: 404 }
])

// âŒ å¾“æ¥ã®è¤‡é›‘ãªmockãƒã‚§ãƒ¼ãƒ³
jest.fn()
  .mockResolvedValueOnce(mockResult1)
  .mockResolvedValueOnce(mockResult2)
  .mockResolvedValueOnce(mockResult3)
  // ... 30+ sequential mocks
```

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ¢ãƒƒã‚¯

#### Serviceå±¤ãƒ¢ãƒƒã‚¯

```typescript
// __tests__/mocks/services.ts
export class MockSlackService {
  private mockResults: SlackServiceResult<any>[] = []
  private callIndex = 0

  setMockResults(results: SlackServiceResult<any>[]) {
    this.mockResults = results
    this.callIndex = 0
  }

  async processWebhookEvent(
    webhookId: string,
    payload: SlackEventPayload
  ): Promise<SlackServiceResult<WebhookProcessingResult>> {
    return this.getNextResult()
  }

  private getNextResult(): SlackServiceResult<any> {
    if (this.callIndex >= this.mockResults.length) {
      throw new Error(`MockSlackService: No more mock results available (called ${this.callIndex} times)`)
    }
    return this.mockResults[this.callIndex++]
  }
}
```

#### Repositoryå±¤ãƒ¢ãƒƒã‚¯

```typescript
// __tests__/mocks/repositories.ts
export class MockSlackRepository implements SlackRepositoryInterface {
  private mockResults: RepositoryResult<any>[] = []
  private callIndex = 0

  setMockResults(results: RepositoryResult<any>[]) {
    this.mockResults = results
    this.callIndex = 0
  }

  async findWebhookById(webhookId: string): Promise<RepositoryResult<SlackWebhook>> {
    return this.getNextResult()
  }

  async createTodoFromSlackMessage(
    userId: string,
    todoData: Partial<Todo>
  ): Promise<RepositoryResult<Todo>> {
    return this.getNextResult()
  }

  private getNextResult(): RepositoryResult<any> {
    if (this.callIndex >= this.mockResults.length) {
      throw new Error('MockSlackRepository: No more mock results available')
    }
    return this.mockResults[this.callIndex++]
  }
}
```

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ¢ãƒƒã‚¯

#### Use Caseså±¤ãƒ¢ãƒƒã‚¯

```typescript
// __tests__/mocks/use-cases.ts
export class MockTodoUseCases {
  private mockResults: UseCaseResult<any>[] = []
  private callIndex = 0

  setMockResults(results: UseCaseResult<any>[]) {
    this.mockResults = results
    this.callIndex = 0
  }

  async createTodo(params: CreateTodoParams): Promise<UseCaseResult<TodoEntity>> {
    return this.getNextResult()
  }

  async updateTodo(params: UpdateTodoParams): Promise<UseCaseResult<TodoEntity>> {
    return this.getNextResult()
  }

  private getNextResult(): UseCaseResult<any> {
    if (this.callIndex >= this.mockResults.length) {
      throw new Error('MockTodoUseCases: No more mock results available')
    }
    return this.mockResults[this.callIndex++]
  }
}
```

#### Frontend Repositoryå±¤ãƒ¢ãƒƒã‚¯

```typescript
// __tests__/mocks/frontend-repositories.ts
export class MockTodoRepository implements TodoRepositoryInterface {
  private mockResults: RepositoryResult<any>[] = []
  private callIndex = 0

  setMockResults(results: RepositoryResult<any>[]) {
    this.mockResults = results
    this.callIndex = 0
  }

  async findById(id: string): Promise<RepositoryResult<TodoEntity>> {
    return this.getNextResult()
  }

  async create(params: CreateTodoParams): Promise<RepositoryResult<TodoEntity>> {
    return this.getNextResult()
  }

  private getNextResult(): RepositoryResult<any> {
    if (this.callIndex >= this.mockResults.length) {
      throw new Error('MockTodoRepository: No more mock results available')
    }
    return this.mockResults[this.callIndex++]
  }
}
```

## ğŸ§© ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

### Fixtureé–¢æ•°

#### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰Fixture

```typescript
// __tests__/fixtures/entities.ts
export const createMockTodo = (overrides: Partial<Todo> = {}): Todo => ({
  id: 'mock-todo-id',
  user_id: 'mock-user-id',
  title: 'Mock Todo',
  description: 'Mock description',
  deadline: null,
  importance_score: 0.5,
  status: 'open',
  slack_url: null,
  created_via: 'manual',
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString(),
  ...overrides
})

export const createMockSlackPayload = (overrides: Partial<SlackEventPayload> = {}): SlackEventPayload => ({
  type: 'event_callback',
  event: {
    type: 'reaction_added',
    user: 'U1234567890',
    reaction: 'memo',
    item: {
      channel: 'C1234567890',
      ts: '1234567890.123456'
    }
  },
  ...overrides
})
```

#### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰Fixture

```typescript
// __tests__/fixtures/frontend-entities.ts
export const createMockTodoEntity = (overrides: Partial<TodoData> = {}): TodoEntity => {
  const todoData = {
    id: 'mock-todo-id',
    userId: 'mock-user-id',
    title: 'Mock Todo',
    body: 'Mock description',
    deadline: null,
    importanceScore: 0.5,
    status: 'open' as TodoStatus,
    createdVia: 'manual' as TodoCreatedVia,
    createdAt: new Date().toISOString(),
    ...overrides
  }
  return new TodoEntity(todoData)
}

export const createMockUserEntity = (overrides: Partial<UserData> = {}): UserEntity => {
  const userData = {
    id: 'mock-user-id',
    email: 'test@example.com',
    profile: {
      displayName: 'Test User',
      avatarUrl: null
    },
    ...overrides
  }
  return new UserEntity(userData)
}
```

### Helperé–¢æ•°

```typescript
// __tests__/helpers/date-helpers.ts
export const getDateString = (daysFromToday: number): string => {
  const date = new Date()
  date.setDate(date.getDate() + daysFromToday)
  return date.toISOString().split('T')[0]
}

export const getTodayString = (): string => getDateString(0)
export const getTomorrowString = (): string => getDateString(1)
export const getYesterdayString = (): string => getDateString(-1)
```

## ğŸš€ ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

### åŸºæœ¬ã‚³ãƒãƒ³ãƒ‰

```bash
# å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm run test

# ç›£è¦–ãƒ¢ãƒ¼ãƒ‰ã§ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm run test:watch

# ã‚«ãƒãƒ¬ãƒƒã‚¸ä»˜ããƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm run test:coverage

# ç‰¹å®šã®ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿å®Ÿè¡Œ
npm test SlackService.test.ts

# ç‰¹å®šã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®ã¿å®Ÿè¡Œ
npm test -- --testNamePattern="should process valid webhook event"
```

### ãƒ†ã‚¹ãƒˆè¨­å®š

```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/$1'
  },
  collectCoverageFrom: [
    'lib/**/*.{ts,tsx}',
    'app/api/**/*.{ts,tsx}',
    '!**/*.d.ts',
    '!**/node_modules/**'
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70
    }
  }
}
```

## ğŸ“Š ã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰

#### Serviceå±¤
- **é–¢æ•°ã‚«ãƒãƒ¬ãƒƒã‚¸**: 90%ä»¥ä¸Š
- **ãƒ–ãƒ©ãƒ³ãƒã‚«ãƒãƒ¬ãƒƒã‚¸**: 85%ä»¥ä¸Š
- **è¡Œã‚«ãƒãƒ¬ãƒƒã‚¸**: 90%ä»¥ä¸Š

#### Repositoryå±¤
- **é–¢æ•°ã‚«ãƒãƒ¬ãƒƒã‚¸**: 80%ä»¥ä¸Š
- **ãƒ–ãƒ©ãƒ³ãƒã‚«ãƒãƒ¬ãƒƒã‚¸**: 75%ä»¥ä¸Š
- **è¡Œã‚«ãƒãƒ¬ãƒƒã‚¸**: 80%ä»¥ä¸Š

#### Entityå±¤
- **é–¢æ•°ã‚«ãƒãƒ¬ãƒƒã‚¸**: 95%ä»¥ä¸Š
- **ãƒ–ãƒ©ãƒ³ãƒã‚«ãƒãƒ¬ãƒƒã‚¸**: 90%ä»¥ä¸Š
- **è¡Œã‚«ãƒãƒ¬ãƒƒã‚¸**: 95%ä»¥ä¸Š

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰

#### Use Caseså±¤
- **é–¢æ•°ã‚«ãƒãƒ¬ãƒƒã‚¸**: 90%ä»¥ä¸Š
- **ãƒ–ãƒ©ãƒ³ãƒã‚«ãƒãƒ¬ãƒƒã‚¸**: 85%ä»¥ä¸Š
- **è¡Œã‚«ãƒãƒ¬ãƒƒã‚¸**: 90%ä»¥ä¸Š

#### Repositoryå±¤
- **é–¢æ•°ã‚«ãƒãƒ¬ãƒƒã‚¸**: 85%ä»¥ä¸Š
- **ãƒ–ãƒ©ãƒ³ãƒã‚«ãƒãƒ¬ãƒƒã‚¸**: 80%ä»¥ä¸Š
- **è¡Œã‚«ãƒãƒ¬ãƒƒã‚¸**: 85%ä»¥ä¸Š

#### Entityå±¤
- **é–¢æ•°ã‚«ãƒãƒ¬ãƒƒã‚¸**: 95%ä»¥ä¸Š
- **ãƒ–ãƒ©ãƒ³ãƒã‚«ãƒãƒ¬ãƒƒã‚¸**: 90%ä»¥ä¸Š
- **è¡Œã‚«ãƒãƒ¬ãƒƒã‚¸**: 95%ä»¥ä¸Š

#### Presentationå±¤ï¼ˆã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ï¼‰
- **é–¢æ•°ã‚«ãƒãƒ¬ãƒƒã‚¸**: 80%ä»¥ä¸Š
- **ãƒ–ãƒ©ãƒ³ãƒã‚«ãƒãƒ¬ãƒƒã‚¸**: 75%ä»¥ä¸Š
- **è¡Œã‚«ãƒãƒ¬ãƒƒã‚¸**: 80%ä»¥ä¸Š

## ğŸ› ãƒ†ã‚¹ãƒˆãƒ‡ãƒãƒƒã‚°

### ä¸€èˆ¬çš„ãªãƒ†ã‚¹ãƒˆå¤±æ•—ã®åŸå› 

1. **Dateãƒ»Timeé–¢é€£**
   ```typescript
   // âŒ ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã®å•é¡Œ
   expect(todo.isUrgent()).toBe(true)  // ç¾åœ°æ™‚é–“ä¾å­˜
   
   // âœ… å›ºå®šã®æ—¥ä»˜ã‚’ä½¿ç”¨
   const mockDate = '2025-01-01'
   const todo = createMockTodo({ deadline: mockDate })
   ```

2. **éåŒæœŸå‡¦ç†**
   ```typescript
   // âŒ awaitã‚’å¿˜ã‚Œã‚‹
   const result = slackService.processWebhookEvent(webhookId, payload)
   
   // âœ… é©åˆ‡ãªéåŒæœŸå‡¦ç†
   const result = await slackService.processWebhookEvent(webhookId, payload)
   ```

3. **Mockè¨­å®šã®ä¸å‚™**
   ```typescript
   // âŒ MockçµæœãŒä¸è¶³
   mockService.setMockResults([result1])
   await service.methodThatCallsTwice()  // ã‚¨ãƒ©ãƒ¼
   
   // âœ… ååˆ†ãªMockçµæœã‚’ç”¨æ„
   mockService.setMockResults([result1, result2])
   ```

### ãƒ‡ãƒãƒƒã‚°æ–¹æ³•

```typescript
// ãƒ†ã‚¹ãƒˆä¸­ã®ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›
describe('SlackService', () => {
  test('debug test', async () => {
    console.log('Test input:', { webhookId, payload })
    
    const result = await slackService.processWebhookEvent(webhookId, payload)
    
    console.log('Test result:', result)
    expect(result.success).toBe(true)
  })
})
```

## ğŸ” ãƒ†ã‚¹ãƒˆãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### Arrange-Act-Assert ãƒ‘ã‚¿ãƒ¼ãƒ³

```typescript
test('should create todo from slack message', async () => {
  // Arrange - ãƒ†ã‚¹ãƒˆã®æº–å‚™
  const webhookId = 'test-webhook-id'
  const payload = createMockSlackPayload()
  mockSlackRepo.setMockResults([validWebhookResult])
  
  // Act - ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®å®Ÿè¡Œ
  const result = await slackService.processWebhookEvent(webhookId, payload)
  
  // Assert - çµæœã®æ¤œè¨¼
  expect(result.success).toBe(true)
  expect(result.data.todo).toBeDefined()
})
```

### é©åˆ‡ãªãƒ†ã‚¹ãƒˆå

```typescript
// âœ… è‰¯ã„ãƒ†ã‚¹ãƒˆå
test('should return 404 when webhook not found')
test('should create todo with correct urgency for memo emoji')
test('should reject event from non-connected user')

// âŒ æ‚ªã„ãƒ†ã‚¹ãƒˆå
test('webhook test')
test('it works')
test('test1')
```

### ãƒ†ã‚¹ãƒˆã®ç‹¬ç«‹æ€§

```typescript
// âœ… å„ãƒ†ã‚¹ãƒˆã§æ–°ã—ã„ãƒ¢ãƒƒã‚¯ã‚’ä½œæˆ
beforeEach(() => {
  mockSlackRepo = new MockSlackRepository()
  mockTodoRepo = new MockTodoRepository()
  slackService = new SlackService(mockSlackRepo, mockTodoRepo)
})

// âŒ ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªãƒ¢ãƒƒã‚¯ã®å†åˆ©ç”¨
let globalMockService = new MockSlackService()  // å±é™º
```

## ğŸ“‹ ç¶™ç¶šçš„ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

### CI/CDã§ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

```yaml
# .github/workflows/test.yml
name: Tests
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run lint
      - run: npm run test:coverage
      - run: npm run build
```

### ãƒ†ã‚¹ãƒˆå ±å‘Š

```bash
# ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
npm run test:coverage

# CIç’°å¢ƒã§ã®ãƒ†ã‚¹ãƒˆçµæœå‡ºåŠ›
npm run test -- --ci --coverage --watchAll=false
```

## ğŸ“š é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [é–‹ç™ºã‚¬ã‚¤ãƒ‰](./DEVELOPMENT.md) - é–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹ã¨ãƒ«ãƒ¼ãƒ«
- [ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¬ã‚¤ãƒ‰](./SECURITY.md) - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
- [ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦](../architecture/ARCHITECTURE.md) - ãƒ†ã‚¹ãƒˆå¯èƒ½ãªè¨­è¨ˆ
- [APIä»•æ§˜](../architecture/API.md) - APIãƒ†ã‚¹ãƒˆã®è©³ç´°