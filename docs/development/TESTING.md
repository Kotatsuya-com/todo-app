# „ÉÜ„Çπ„Éà„Ç¨„Ç§„Éâ

## üß™ „ÉÜ„Çπ„ÉàÊà¶Áï•

Clean Architecture„Éë„Çø„Éº„É≥„Å´Âü∫„Å•„ÅÑ„ÅüÂäπÁéáÁöÑ„Å™„ÉÜ„Çπ„ÉàÊà¶Áï•„ÇíÊé°Áî®„Åó„ÄÅ‰øùÂÆàÊÄß„Å®„ÉÜ„Çπ„Çø„Éì„É™„ÉÜ„Ç£„ÇíÈáçË¶ñ„Åó„Åü„ÉÜ„Çπ„ÉàÂÆüË£Ö„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇ

## üéØ „ÉÜ„Çπ„ÉàÂØæË±°„ÅÆÂÑ™ÂÖàÈ†Ü‰Ωç

### 1. ServiceÂ±§ÔºàÊúÄÈáçË¶ÅÔºâ
**„Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØ„ÅÆÂçò‰Ωì„ÉÜ„Çπ„Éà**
- Ë§áÈõë„Å™„Éì„Ç∏„Éç„Çπ„É´„Éº„É´„ÅÆÊ§úË®º
- Â§ñÈÉ®APIÈÄ£Êê∫„ÅÆÂãï‰ΩúÁ¢∫Ë™ç
- „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„ÅÆÊ§úË®º

### 2. RepositoryÂ±§
**„Éá„Éº„Çø„Ç¢„ÇØ„Çª„Çπ„É≠„Ç∏„ÉÉ„ÇØ„ÅÆ„ÉÜ„Çπ„Éà**
- CRUDÊìç‰Ωú„ÅÆÂãï‰ΩúÁ¢∫Ë™ç
- „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„ÅÆÊ§úË®º
- „Éá„Éº„ÇøÂ§âÊèõ„ÅÆÊ≠£Á¢∫ÊÄß

### 3. EntityÂ±§
**„Éâ„É°„Ç§„É≥„É≠„Ç∏„ÉÉ„ÇØ„Å®„Éê„É™„Éá„Éº„Ç∑„Éß„É≥„ÅÆ„ÉÜ„Çπ„Éà**
- „Éì„Ç∏„Éç„Çπ„É´„Éº„É´„ÅÆÊ§úË®º
- Áä∂ÊÖãÂ§âÊõ¥„ÅÆÊ≠£Á¢∫ÊÄß
- „Éê„É™„Éá„Éº„Ç∑„Éß„É≥Ê©üËÉΩ

### 4. APIÂ±§
**Áµ±Âêà„ÉÜ„Çπ„ÉàÔºàServiceÂ±§„É¢„ÉÉ„ÇØ‰ΩøÁî®Ôºâ**
- HTTP„É™„ÇØ„Ç®„Çπ„Éà„Éª„É¨„Çπ„Éù„É≥„Çπ„ÅÆÊ§úË®º
- Ë™çË®º„ÉªË™çÂèØ„ÅÆÂãï‰ΩúÁ¢∫Ë™ç
- „Ç®„É©„Éº„É¨„Çπ„Éù„É≥„Çπ„ÅÆÊ§úË®º

## üìù „ÉÜ„Çπ„Éà„Éë„Çø„Éº„É≥

### ServiceÂ±§„ÉÜ„Çπ„Éà‰æã

```typescript
// __tests__/lib/services/SlackService.test.ts
import { SlackService } from '@/lib/services/SlackService'
import { MockSlackRepository } from '@/__tests__/mocks/repositories'
import { MockTodoRepository } from '@/__tests__/mocks/repositories'

describe('SlackService', () => {
  let slackService: SlackService
  let mockSlackRepo: MockSlackRepository
  let mockTodoRepo: MockTodoRepository

  beforeEach(() => {
    mockSlackRepo = new MockSlackRepository()
    mockTodoRepo = new MockTodoRepository()
    slackService = new SlackService(mockSlackRepo, mockTodoRepo)
  })

  describe('processWebhookEvent', () => {
    test('should process valid webhook event successfully', async () => {
      // Arrange
      const webhookId = 'test-webhook-id'
      const payload = createMockSlackPayload()
      
      mockSlackRepo.setMockResults([
        { success: true, data: createMockWebhook() },
        { success: true, data: createMockConnection() }
      ])
      
      mockTodoRepo.setMockResults([
        { success: true, data: createMockTodo() }
      ])

      // Act
      const result = await slackService.processWebhookEvent(webhookId, payload)

      // Assert
      expect(result.success).toBe(true)
      expect(result.statusCode).toBe(200)
      expect(result.data).toBeDefined()
    })

    test('should return 404 when webhook not found', async () => {
      // Arrange
      const webhookId = 'non-existent-webhook'
      const payload = createMockSlackPayload()
      
      mockSlackRepo.setMockResults([
        { success: false, error: 'Webhook not found' }
      ])

      // Act
      const result = await slackService.processWebhookEvent(webhookId, payload)

      // Assert
      expect(result.success).toBe(false)
      expect(result.statusCode).toBe(404)
      expect(result.error).toBe('Webhook not found')
    })
  })
})
```

### EntityÂ±§„ÉÜ„Çπ„Éà‰æã

```typescript
// __tests__/lib/entities/Todo.test.ts
import { TodoEntity } from '@/lib/entities/Todo'
import { createMockTodo } from '@/__tests__/fixtures/entities'

describe('TodoEntity', () => {
  describe('getQuadrant', () => {
    test('should return urgent_important for urgent and important task', () => {
      // Arrange
      const todoData = createMockTodo({
        deadline: new Date().toISOString().split('T')[0], // Today
        importance_score: 0.8
      })
      const todo = new TodoEntity(todoData)

      // Act
      const quadrant = todo.getQuadrant()

      // Assert
      expect(quadrant).toBe('urgent_important')
    })

    test('should return not_urgent_important for future important task', () => {
      // Arrange
      const futureDate = new Date()
      futureDate.setDate(futureDate.getDate() + 7)
      
      const todoData = createMockTodo({
        deadline: futureDate.toISOString().split('T')[0],
        importance_score: 0.8
      })
      const todo = new TodoEntity(todoData)

      // Act
      const quadrant = todo.getQuadrant()

      // Assert
      expect(quadrant).toBe('not_urgent_important')
    })
  })

  describe('isUrgent', () => {
    test('should return true for task with deadline today or past', () => {
      // Arrange
      const todoData = createMockTodo({
        deadline: new Date().toISOString().split('T')[0]
      })
      const todo = new TodoEntity(todoData)

      // Act
      const isUrgent = todo.isUrgent()

      // Assert
      expect(isUrgent).toBe(true)
    })

    test('should return false for task without deadline', () => {
      // Arrange
      const todoData = createMockTodo({ deadline: null })
      const todo = new TodoEntity(todoData)

      // Act
      const isUrgent = todo.isUrgent()

      // Assert
      expect(isUrgent).toBe(false)
    })
  })

  describe('isImportant', () => {
    test('should return true for high importance score', () => {
      // Arrange
      const todoData = createMockTodo({ importance_score: 0.8 })
      const todo = new TodoEntity(todoData)

      // Act
      const isImportant = todo.isImportant()

      // Assert
      expect(isImportant).toBe(true)
    })

    test('should return false for low importance score', () => {
      // Arrange
      const todoData = createMockTodo({ importance_score: 0.2 })
      const todo = new TodoEntity(todoData)

      // Act
      const isImportant = todo.isImportant()

      // Assert
      expect(isImportant).toBe(false)
    })
  })
})
```

### APIÂ±§„ÉÜ„Çπ„Éà‰æã

```typescript
// __tests__/api/slack/events/user/[webhook_id]/route.test.ts
import { POST } from '@/app/api/slack/events/user/[webhook_id]/route'
import { NextRequest } from 'next/server'
import { MockSlackService } from '@/__tests__/mocks/services'

// ServiceÂ±§„ÅÆ„É¢„ÉÉ„ÇØ
jest.mock('@/lib/services/ServiceFactory', () => ({
  createServices: () => ({
    slackService: new MockSlackService()
  })
}))

describe('/api/slack/events/user/[webhook_id]', () => {
  let mockSlackService: MockSlackService

  beforeEach(() => {
    const { slackService } = require('@/lib/services/ServiceFactory').createServices()
    mockSlackService = slackService
  })

  test('should process valid webhook event', async () => {
    // Arrange
    const webhookId = 'test-webhook-id'
    const payload = createMockSlackPayload()
    
    mockSlackService.setMockResults([
      { success: true, data: { message: 'Event processed' }, statusCode: 200 }
    ])

    const request = new NextRequest('http://localhost:3000/api/slack/events/user/' + webhookId, {
      method: 'POST',
      body: JSON.stringify(payload),
      headers: { 'Content-Type': 'application/json' }
    })

    // Act
    const response = await POST(request, { params: { webhook_id: webhookId } })
    const responseBody = await response.json()

    // Assert
    expect(response.status).toBe(200)
    expect(responseBody.message).toBe('Event processed')
  })

  test('should return 404 for non-existent webhook', async () => {
    // Arrange
    const webhookId = 'non-existent-webhook'
    const payload = createMockSlackPayload()
    
    mockSlackService.setMockResults([
      { success: false, error: 'Webhook not found', statusCode: 404 }
    ])

    const request = new NextRequest('http://localhost:3000/api/slack/events/user/' + webhookId, {
      method: 'POST',
      body: JSON.stringify(payload)
    })

    // Act
    const response = await POST(request, { params: { webhook_id: webhookId } })
    const responseBody = await response.json()

    // Assert
    expect(response.status).toBe(404)
    expect(responseBody.error).toBe('Webhook not found')
  })
})
```

## üîß „É¢„ÉÉ„ÇØ„Ç∑„Çπ„ÉÜ„É†

### Result-Based Mocking

ÂæìÊù•„ÅÆË§áÈõë„Å™mock„ÉÅ„Çß„Éº„É≥„ÇíÁ∞°ÊΩî„Å™ÁµêÊûú„Éô„Éº„Çπ„ÅÆ„Ç¢„Éó„É≠„Éº„ÉÅ„Å´ÁΩÆ„ÅçÊèõ„ÅàÔºö

```typescript
// ‚úÖ Result-Based Approach
export class MockSlackService {
  private mockResults: any[] = []
  private callIndex = 0

  setMockResults(results: any[]) {
    this.mockResults = results
    this.callIndex = 0
  }

  async processWebhookEvent(webhookId: string, payload: any) {
    const result = this.getNextResult()
    return result
  }

  private getNextResult() {
    if (this.callIndex >= this.mockResults.length) {
      throw new Error('No more mock results available')
    }
    return this.mockResults[this.callIndex++]
  }
}

// ‚ùå ÂæìÊù•„ÅÆË§áÈõë„Å™mock„ÉÅ„Çß„Éº„É≥
jest.fn()
  .mockResolvedValueOnce(mockResult1)
  .mockResolvedValueOnce(mockResult2)
  .mockResolvedValueOnce(mockResult3)
  // ... 30+ sequential mocks
```

### ServiceÂ±§„É¢„ÉÉ„ÇØ

```typescript
// __tests__/mocks/services.ts
export class MockSlackService {
  private mockResults: SlackServiceResult<any>[] = []
  private callIndex = 0

  setMockResults(results: SlackServiceResult<any>[]) {
    this.mockResults = results
    this.callIndex = 0
  }

  async processWebhookEvent(
    webhookId: string,
    payload: SlackEventPayload
  ): Promise<SlackServiceResult<WebhookProcessingResult>> {
    return this.getNextResult()
  }

  private getNextResult(): SlackServiceResult<any> {
    if (this.callIndex >= this.mockResults.length) {
      throw new Error(`MockSlackService: No more mock results available (called ${this.callIndex} times)`)
    }
    return this.mockResults[this.callIndex++]
  }
}
```

### RepositoryÂ±§„É¢„ÉÉ„ÇØ

```typescript
// __tests__/mocks/repositories.ts
export class MockSlackRepository implements SlackRepositoryInterface {
  private mockResults: RepositoryResult<any>[] = []
  private callIndex = 0

  setMockResults(results: RepositoryResult<any>[]) {
    this.mockResults = results
    this.callIndex = 0
  }

  async findWebhookById(webhookId: string): Promise<RepositoryResult<SlackWebhook>> {
    return this.getNextResult()
  }

  async createTodoFromSlackMessage(
    userId: string,
    todoData: Partial<Todo>
  ): Promise<RepositoryResult<Todo>> {
    return this.getNextResult()
  }

  private getNextResult(): RepositoryResult<any> {
    if (this.callIndex >= this.mockResults.length) {
      throw new Error('MockSlackRepository: No more mock results available')
    }
    return this.mockResults[this.callIndex++]
  }
}
```

## üß© „ÉÜ„Çπ„Éà„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£

### FixtureÈñ¢Êï∞

```typescript
// __tests__/fixtures/entities.ts
export const createMockTodo = (overrides: Partial<Todo> = {}): Todo => ({
  id: 'mock-todo-id',
  user_id: 'mock-user-id',
  title: 'Mock Todo',
  description: 'Mock description',
  deadline: null,
  importance_score: 0.5,
  status: 'open',
  slack_url: null,
  created_via: 'manual',
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString(),
  ...overrides
})

export const createMockSlackPayload = (overrides: Partial<SlackEventPayload> = {}): SlackEventPayload => ({
  type: 'event_callback',
  event: {
    type: 'reaction_added',
    user: 'U1234567890',
    reaction: 'memo',
    item: {
      channel: 'C1234567890',
      ts: '1234567890.123456'
    }
  },
  ...overrides
})
```

### HelperÈñ¢Êï∞

```typescript
// __tests__/helpers/date-helpers.ts
export const getDateString = (daysFromToday: number): string => {
  const date = new Date()
  date.setDate(date.getDate() + daysFromToday)
  return date.toISOString().split('T')[0]
}

export const getTodayString = (): string => getDateString(0)
export const getTomorrowString = (): string => getDateString(1)
export const getYesterdayString = (): string => getDateString(-1)
```

## üöÄ „ÉÜ„Çπ„ÉàÂÆüË°å

### Âü∫Êú¨„Ç≥„Éû„É≥„Éâ

```bash
# ÂÖ®„ÉÜ„Çπ„ÉàÂÆüË°å
npm run test

# Áõ£Ë¶ñ„É¢„Éº„Éâ„Åß„ÉÜ„Çπ„ÉàÂÆüË°å
npm run test:watch

# „Ç´„Éê„É¨„ÉÉ„Ç∏‰ªò„Åç„ÉÜ„Çπ„ÉàÂÆüË°å
npm run test:coverage

# ÁâπÂÆö„ÅÆ„ÉÜ„Çπ„Éà„Éï„Ç°„Ç§„É´„ÅÆ„ÅøÂÆüË°å
npm test SlackService.test.ts

# ÁâπÂÆö„ÅÆ„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„ÅÆ„ÅøÂÆüË°å
npm test -- --testNamePattern="should process valid webhook event"
```

### „ÉÜ„Çπ„ÉàË®≠ÂÆö

```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/$1'
  },
  collectCoverageFrom: [
    'lib/**/*.{ts,tsx}',
    'app/api/**/*.{ts,tsx}',
    '!**/*.d.ts',
    '!**/node_modules/**'
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70
    }
  }
}
```

## üìä „Ç´„Éê„É¨„ÉÉ„Ç∏ÁõÆÊ®ô

### ServiceÂ±§
- **Èñ¢Êï∞„Ç´„Éê„É¨„ÉÉ„Ç∏**: 90%‰ª•‰∏ä
- **„Éñ„É©„É≥„ÉÅ„Ç´„Éê„É¨„ÉÉ„Ç∏**: 85%‰ª•‰∏ä
- **Ë°å„Ç´„Éê„É¨„ÉÉ„Ç∏**: 90%‰ª•‰∏ä

### RepositoryÂ±§
- **Èñ¢Êï∞„Ç´„Éê„É¨„ÉÉ„Ç∏**: 80%‰ª•‰∏ä
- **„Éñ„É©„É≥„ÉÅ„Ç´„Éê„É¨„ÉÉ„Ç∏**: 75%‰ª•‰∏ä
- **Ë°å„Ç´„Éê„É¨„ÉÉ„Ç∏**: 80%‰ª•‰∏ä

### EntityÂ±§
- **Èñ¢Êï∞„Ç´„Éê„É¨„ÉÉ„Ç∏**: 95%‰ª•‰∏ä
- **„Éñ„É©„É≥„ÉÅ„Ç´„Éê„É¨„ÉÉ„Ç∏**: 90%‰ª•‰∏ä
- **Ë°å„Ç´„Éê„É¨„ÉÉ„Ç∏**: 95%‰ª•‰∏ä

## üêõ „ÉÜ„Çπ„Éà„Éá„Éê„ÉÉ„Ç∞

### ‰∏ÄËà¨ÁöÑ„Å™„ÉÜ„Çπ„ÉàÂ§±Êïó„ÅÆÂéüÂõ†

1. **Date„ÉªTimeÈñ¢ÈÄ£**
   ```typescript
   // ‚ùå „Çø„Ç§„É†„Çæ„Éº„É≥„ÅÆÂïèÈ°å
   expect(todo.isUrgent()).toBe(true)  // ÁèæÂú∞ÊôÇÈñì‰æùÂ≠ò
   
   // ‚úÖ Âõ∫ÂÆö„ÅÆÊó•‰ªò„Çí‰ΩøÁî®
   const mockDate = '2025-01-01'
   const todo = createMockTodo({ deadline: mockDate })
   ```

2. **ÈùûÂêåÊúüÂá¶ÁêÜ**
   ```typescript
   // ‚ùå await„ÇíÂøò„Çå„Çã
   const result = slackService.processWebhookEvent(webhookId, payload)
   
   // ‚úÖ ÈÅ©Âàá„Å™ÈùûÂêåÊúüÂá¶ÁêÜ
   const result = await slackService.processWebhookEvent(webhookId, payload)
   ```

3. **MockË®≠ÂÆö„ÅÆ‰∏çÂÇô**
   ```typescript
   // ‚ùå MockÁµêÊûú„Åå‰∏çË∂≥
   mockService.setMockResults([result1])
   await service.methodThatCallsTwice()  // „Ç®„É©„Éº
   
   // ‚úÖ ÂçÅÂàÜ„Å™MockÁµêÊûú„ÇíÁî®ÊÑè
   mockService.setMockResults([result1, result2])
   ```

### „Éá„Éê„ÉÉ„Ç∞ÊñπÊ≥ï

```typescript
// „ÉÜ„Çπ„Éà‰∏≠„ÅÆ„Éá„Éê„ÉÉ„Ç∞Âá∫Âäõ
describe('SlackService', () => {
  test('debug test', async () => {
    console.log('Test input:', { webhookId, payload })
    
    const result = await slackService.processWebhookEvent(webhookId, payload)
    
    console.log('Test result:', result)
    expect(result.success).toBe(true)
  })
})
```

## üîç „ÉÜ„Çπ„Éà„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ

### Arrange-Act-Assert „Éë„Çø„Éº„É≥

```typescript
test('should create todo from slack message', async () => {
  // Arrange - „ÉÜ„Çπ„Éà„ÅÆÊ∫ñÂÇô
  const webhookId = 'test-webhook-id'
  const payload = createMockSlackPayload()
  mockSlackRepo.setMockResults([validWebhookResult])
  
  // Act - „ÉÜ„Çπ„ÉàÂØæË±°„ÅÆÂÆüË°å
  const result = await slackService.processWebhookEvent(webhookId, payload)
  
  // Assert - ÁµêÊûú„ÅÆÊ§úË®º
  expect(result.success).toBe(true)
  expect(result.data.todo).toBeDefined()
})
```

### ÈÅ©Âàá„Å™„ÉÜ„Çπ„ÉàÂêç

```typescript
// ‚úÖ ËâØ„ÅÑ„ÉÜ„Çπ„ÉàÂêç
test('should return 404 when webhook not found')
test('should create todo with correct urgency for memo emoji')
test('should reject event from non-connected user')

// ‚ùå ÊÇ™„ÅÑ„ÉÜ„Çπ„ÉàÂêç
test('webhook test')
test('it works')
test('test1')
```

### „ÉÜ„Çπ„Éà„ÅÆÁã¨Á´ãÊÄß

```typescript
// ‚úÖ ÂêÑ„ÉÜ„Çπ„Éà„ÅßÊñ∞„Åó„ÅÑ„É¢„ÉÉ„ÇØ„Çí‰ΩúÊàê
beforeEach(() => {
  mockSlackRepo = new MockSlackRepository()
  mockTodoRepo = new MockTodoRepository()
  slackService = new SlackService(mockSlackRepo, mockTodoRepo)
})

// ‚ùå „Ç∞„É≠„Éº„Éê„É´„Å™„É¢„ÉÉ„ÇØ„ÅÆÂÜçÂà©Áî®
let globalMockService = new MockSlackService()  // Âç±Èô∫
```

## üìã Á∂ôÁ∂öÁöÑ„Ç§„É≥„ÉÜ„Ç∞„É¨„Éº„Ç∑„Éß„É≥

### CI/CD„Åß„ÅÆ„ÉÜ„Çπ„ÉàÂÆüË°å

```yaml
# .github/workflows/test.yml
name: Tests
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run lint
      - run: npm run test:coverage
      - run: npm run build
```

### „ÉÜ„Çπ„ÉàÂ†±Âëä

```bash
# „Ç´„Éê„É¨„ÉÉ„Ç∏„É¨„Éù„Éº„Éà„ÅÆÁîüÊàê
npm run test:coverage

# CIÁí∞Â¢É„Åß„ÅÆ„ÉÜ„Çπ„ÉàÁµêÊûúÂá∫Âäõ
npm run test -- --ci --coverage --watchAll=false
```

## üìö Èñ¢ÈÄ£„Éâ„Ç≠„É•„É°„É≥„Éà

- [ÈñãÁô∫„Ç¨„Ç§„Éâ](./DEVELOPMENT.md) - ÈñãÁô∫„Éó„É≠„Çª„Çπ„Å®„É´„Éº„É´
- [„Çª„Ç≠„É•„É™„ÉÜ„Ç£„Ç¨„Ç§„Éâ](./SECURITY.md) - „Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÜ„Çπ„Éà
- [„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ê¶ÇË¶Å](../architecture/ARCHITECTURE.md) - „ÉÜ„Çπ„ÉàÂèØËÉΩ„Å™Ë®≠Ë®à
- [API‰ªïÊßò](../architecture/API.md) - API„ÉÜ„Çπ„Éà„ÅÆË©≥Á¥∞