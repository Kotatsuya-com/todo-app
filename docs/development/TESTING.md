# ãƒ†ã‚¹ãƒˆã‚¬ã‚¤ãƒ‰

## ğŸ§ª ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

Clean Architectureãƒ‘ã‚¿ãƒ¼ãƒ³ã«åŸºã¥ã„ãŸåŠ¹ç‡çš„ãªãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã‚’æ¡ç”¨ã—ã€ä¿å®ˆæ€§ã¨ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£ã‚’é‡è¦–ã—ãŸãƒ†ã‚¹ãƒˆå®Ÿè£…ã‚’è¡Œã„ã¾ã™ã€‚

**ğŸ‰ 2025å¹´8æœˆ: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ»ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å®Œå…¨å¯¾å¿œ**

## ğŸ¯ ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®å„ªå…ˆé †ä½

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆ

#### 1. Serviceå±¤ï¼ˆæœ€é‡è¦ï¼‰
**ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã®å˜ä½“ãƒ†ã‚¹ãƒˆ**
- è¤‡é›‘ãªãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ã®æ¤œè¨¼
- å¤–éƒ¨APIé€£æºã®å‹•ä½œç¢ºèª
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®æ¤œè¨¼

#### 2. Repositoryå±¤
**ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã®ãƒ†ã‚¹ãƒˆ**
- CRUDæ“ä½œã®å‹•ä½œç¢ºèª
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®æ¤œè¨¼
- ãƒ‡ãƒ¼ã‚¿å¤‰æ›ã®æ­£ç¢ºæ€§

#### 3. Entityå±¤
**ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆ**
- ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ã®æ¤œè¨¼
- çŠ¶æ…‹å¤‰æ›´ã®æ­£ç¢ºæ€§
- ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½

#### 4. APIå±¤
**çµ±åˆãƒ†ã‚¹ãƒˆï¼ˆServiceå±¤ãƒ¢ãƒƒã‚¯ä½¿ç”¨ï¼‰**
- HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®æ¤œè¨¼
- èªè¨¼ãƒ»èªå¯ã®å‹•ä½œç¢ºèª
- ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®æ¤œè¨¼

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆ

#### 1. Use Caseså±¤ï¼ˆæœ€é‡è¦ï¼‰
**ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã®å˜ä½“ãƒ†ã‚¹ãƒˆ**
- ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã®å‹•ä½œç¢ºèª
- Repositoryå±¤ã¨ã®é€£æºãƒ†ã‚¹ãƒˆ
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®æ¤œè¨¼

#### 2. Repositoryå±¤
**ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹å®Ÿè£…ã®ãƒ†ã‚¹ãƒˆ**
- Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã®é€£æº
- ãƒ‡ãƒ¼ã‚¿å¤‰æ›ã®æ­£ç¢ºæ€§
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®æ¤œè¨¼

#### 3. Entityå±¤
**ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®ãƒ†ã‚¹ãƒˆ**
- ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ã®æ¤œè¨¼
- ãƒ‡ãƒ¼ã‚¿å¤‰æ›ã®æ­£ç¢ºæ€§
- ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½

#### 4. Presentationå±¤ï¼ˆã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ï¼‰
**UIè«–ç†ã®çµ±åˆãƒ†ã‚¹ãƒˆ**
- ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ã®å‹•ä½œç¢ºèª
- Use Caseså±¤ã¨ã®é€£æºãƒ†ã‚¹ãƒˆ
- çŠ¶æ…‹ç®¡ç†ã®æ¤œè¨¼

## ğŸ“ ãƒ†ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆä¾‹

#### Serviceå±¤ãƒ†ã‚¹ãƒˆä¾‹

```typescript
// __tests__/lib/services/SlackService.test.ts
import { SlackService } from '@/lib/services/SlackService'
import { MockSlackRepository } from '@/__tests__/mocks/repositories'
import { MockTodoRepository } from '@/__tests__/mocks/repositories'

describe('SlackService', () => {
  let slackService: SlackService
  let mockSlackRepo: MockSlackRepository
  let mockTodoRepo: MockTodoRepository

  beforeEach(() => {
    mockSlackRepo = new MockSlackRepository()
    mockTodoRepo = new MockTodoRepository()
    slackService = new SlackService(mockSlackRepo, mockTodoRepo)
  })

  describe('processWebhookEvent', () => {
    test('should process valid webhook event successfully', async () => {
      // Arrange
      const webhookId = 'test-webhook-id'
      const payload = createMockSlackPayload()
      
      mockSlackRepo.setMockResults([
        { success: true, data: createMockWebhook() },
        { success: true, data: createMockConnection() }
      ])
      
      mockTodoRepo.setMockResults([
        { success: true, data: createMockTodo() }
      ])

      // Act
      const result = await slackService.processWebhookEvent(webhookId, payload)

      // Assert
      expect(result.success).toBe(true)
      expect(result.statusCode).toBe(200)
      expect(result.data).toBeDefined()
    })

    test('should return 404 when webhook not found', async () => {
      // Arrange
      const webhookId = 'non-existent-webhook'
      const payload = createMockSlackPayload()
      
      mockSlackRepo.setMockResults([
        { success: false, error: 'Webhook not found' }
      ])

      // Act
      const result = await slackService.processWebhookEvent(webhookId, payload)

      // Assert
      expect(result.success).toBe(false)
      expect(result.statusCode).toBe(404)
      expect(result.error).toBe('Webhook not found')
    })
  })
})
```

#### Entityå±¤ãƒ†ã‚¹ãƒˆä¾‹

```typescript
// __tests__/lib/entities/Todo.test.ts
import { TodoEntity } from '@/lib/entities/Todo'
import { createMockTodo } from '@/__tests__/fixtures/entities'

describe('TodoEntity', () => {
  describe('getQuadrant', () => {
    test('should return urgent_important for urgent and important task', () => {
      // Arrange
      const todoData = createMockTodo({
        deadline: new Date().toISOString().split('T')[0], // Today
        importance_score: 0.8
      })
      const todo = new TodoEntity(todoData)

      // Act
      const quadrant = todo.getQuadrant()

      // Assert
      expect(quadrant).toBe('urgent_important')
    })

    test('should return not_urgent_important for future important task', () => {
      // Arrange
      const futureDate = new Date()
      futureDate.setDate(futureDate.getDate() + 7)
      
      const todoData = createMockTodo({
        deadline: futureDate.toISOString().split('T')[0],
        importance_score: 0.8
      })
      const todo = new TodoEntity(todoData)

      // Act
      const quadrant = todo.getQuadrant()

      // Assert
      expect(quadrant).toBe('not_urgent_important')
    })
  })

  describe('isUrgent', () => {
    test('should return true for task with deadline today or past', () => {
      // Arrange
      const todoData = createMockTodo({
        deadline: new Date().toISOString().split('T')[0]
      })
      const todo = new TodoEntity(todoData)

      // Act
      const isUrgent = todo.isUrgent()

      // Assert
      expect(isUrgent).toBe(true)
    })

    test('should return false for task without deadline', () => {
      // Arrange
      const todoData = createMockTodo({ deadline: null })
      const todo = new TodoEntity(todoData)

      // Act
      const isUrgent = todo.isUrgent()

      // Assert
      expect(isUrgent).toBe(false)
    })
  })

  describe('isImportant', () => {
    test('should return true for high importance score', () => {
      // Arrange
      const todoData = createMockTodo({ importance_score: 0.8 })
      const todo = new TodoEntity(todoData)

      // Act
      const isImportant = todo.isImportant()

      // Assert
      expect(isImportant).toBe(true)
    })

    test('should return false for low importance score', () => {
      // Arrange
      const todoData = createMockTodo({ importance_score: 0.2 })
      const todo = new TodoEntity(todoData)

      // Act
      const isImportant = todo.isImportant()

      // Assert
      expect(isImportant).toBe(false)
    })
  })
})
```

#### APIå±¤ãƒ†ã‚¹ãƒˆä¾‹

```typescript
// __tests__/api/slack/events/user/[webhook_id]/route.test.ts
import { POST } from '@/app/api/slack/events/user/[webhook_id]/route'
import { NextRequest } from 'next/server'
import { MockSlackService } from '@/__tests__/mocks/services'

// Serviceå±¤ã®ãƒ¢ãƒƒã‚¯
jest.mock('@/lib/services/ServiceFactory', () => ({
  createServices: () => ({
    slackService: new MockSlackService()
  })
}))

describe('/api/slack/events/user/[webhook_id]', () => {
  let mockSlackService: MockSlackService

  beforeEach(() => {
    const { slackService } = require('@/lib/services/ServiceFactory').createServices()
    mockSlackService = slackService
  })

  test('should process valid webhook event', async () => {
    // Arrange
    const webhookId = 'test-webhook-id'
    const payload = createMockSlackPayload()
    
    mockSlackService.setMockResults([
      { success: true, data: { message: 'Event processed' }, statusCode: 200 }
    ])

    const request = new NextRequest('http://localhost:3000/api/slack/events/user/' + webhookId, {
      method: 'POST',
      body: JSON.stringify(payload),
      headers: { 'Content-Type': 'application/json' }
    })

    // Act
    const response = await POST(request, { params: { webhook_id: webhookId } })
    const responseBody = await response.json()

    // Assert
    expect(response.status).toBe(200)
    expect(responseBody.message).toBe('Event processed')
  })

  test('should return 404 for non-existent webhook', async () => {
    // Arrange
    const webhookId = 'non-existent-webhook'
    const payload = createMockSlackPayload()
    
    mockSlackService.setMockResults([
      { success: false, error: 'Webhook not found', statusCode: 404 }
    ])

    const request = new NextRequest('http://localhost:3000/api/slack/events/user/' + webhookId, {
      method: 'POST',
      body: JSON.stringify(payload)
    })

    // Act
    const response = await POST(request, { params: { webhook_id: webhookId } })
    const responseBody = await response.json()

    // Assert
    expect(response.status).toBe(404)
    expect(responseBody.error).toBe('Webhook not found')
  })
})
```

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆä¾‹

#### Use Caseså±¤ãƒ†ã‚¹ãƒˆä¾‹

```typescript
// __tests__/src/domain/use-cases/TodoUseCases.test.ts
import { TodoUseCases } from '@/src/domain/use-cases/TodoUseCases'
import { MockTodoRepository } from '@/__tests__/mocks/repositories'

describe('TodoUseCases', () => {
  let todoUseCases: TodoUseCases
  let mockTodoRepo: MockTodoRepository

  beforeEach(() => {
    mockTodoRepo = new MockTodoRepository()
    todoUseCases = new TodoUseCases(mockTodoRepo)
  })

  describe('createTodo', () => {
    test('should create todo successfully', async () => {
      // Arrange
      const params = {
        userId: 'user-123',
        title: 'Test Todo',
        body: 'Test description',
        deadline: '2025-12-31'
      }
      
      mockTodoRepo.setMockResults([
        { success: true, data: createMockTodoEntity() }
      ])

      // Act
      const result = await todoUseCases.createTodo(params)

      // Assert
      expect(result.success).toBe(true)
      expect(result.data).toBeDefined()
    })
  })
})
```

#### Repositoryå±¤ãƒ†ã‚¹ãƒˆä¾‹

```typescript
// __tests__/src/infrastructure/repositories/SupabaseTodoRepository.test.ts
import { SupabaseTodoRepository } from '@/src/infrastructure/repositories/SupabaseTodoRepository'
import { createMockSupabaseClient } from '@/__tests__/mocks/supabase'

describe('SupabaseTodoRepository', () => {
  let repository: SupabaseTodoRepository
  let mockSupabase: any

  beforeEach(() => {
    mockSupabase = createMockSupabaseClient()
    repository = new SupabaseTodoRepository(mockSupabase)
  })

  describe('findById', () => {
    test('should return todo when found', async () => {
      // Arrange
      const todoId = 'todo-123'
      mockSupabase.from.mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            single: jest.fn().mockResolvedValue({
              data: createMockTodoData(),
              error: null
            })
          })
        })
      })

      // Act
      const result = await repository.findById(todoId)

      // Assert
      expect(result.success).toBe(true)
      expect(result.data).toBeInstanceOf(TodoEntity)
    })
  })
})
```

#### ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ãƒ†ã‚¹ãƒˆä¾‹

```typescript
// __tests__/src/presentation/hooks/useAuth.test.ts
import { renderHook, act } from '@testing-library/react'
import { useAuth } from '@/src/presentation/hooks/useAuth'
import { MockAuthUseCases } from '@/__tests__/mocks/use-cases'

// Use Caseså±¤ã®ãƒ¢ãƒƒã‚¯
jest.mock('@/src/infrastructure/di/ServiceFactory', () => ({
  createAuthUseCases: () => new MockAuthUseCases()
}))

describe('useAuth', () => {
  let mockAuthUseCases: MockAuthUseCases

  beforeEach(() => {
    const { createAuthUseCases } = require('@/src/infrastructure/di/ServiceFactory')
    mockAuthUseCases = createAuthUseCases()
  })

  test('should handle user login successfully', async () => {
    // Arrange
    mockAuthUseCases.setMockResults([
      { success: true, data: createMockUserEntity() }
    ])

    const { result } = renderHook(() => useAuth())

    // Act
    await act(async () => {
      const loginResult = await result.current.login('test@example.com', 'password')
      expect(loginResult.success).toBe(true)
    })

    // Assert
    expect(result.current.user).toBeDefined()
    expect(result.current.loading).toBe(false)
  })
})
```

## ğŸ”§ Jestè¨­å®šã®åˆ†é›¢

### ç’°å¢ƒåˆ¥Jestè¨­å®šï¼ˆ2025å¹´8æœˆå®Ÿè£…ï¼‰

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯2ã¤ã®Jestè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ†ã‚¹ãƒˆã‚’é©åˆ‡ãªç’°å¢ƒã§å®Ÿè¡Œã—ã¦ã„ã¾ã™ï¼š

#### jest.config.js - Browserç’°å¢ƒ
- **å¯¾è±¡**: `api/`, `src/`ä»¥ä¸‹ã®ãƒ†ã‚¹ãƒˆ
- **ç’°å¢ƒ**: `jest-environment-jsdom`
- **ç”¨é€”**: React/Next.jsçµ±åˆãƒ†ã‚¹ãƒˆã€APIãƒ«ãƒ¼ãƒˆãƒ†ã‚¹ãƒˆ
- **ãƒ†ã‚¹ãƒˆæ•°**: ç´„280ãƒ†ã‚¹ãƒˆ

#### jest.node.config.js - Node.jsç’°å¢ƒ  
- **å¯¾è±¡**: `lib/`ä»¥ä¸‹ã®ãƒ†ã‚¹ãƒˆ
- **ç’°å¢ƒ**: `node`
- **ç”¨é€”**: ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã€ã‚µãƒ¼ãƒ“ã‚¹å±¤ã€ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
- **ãƒ†ã‚¹ãƒˆæ•°**: ç´„872ãƒ†ã‚¹ãƒˆ

#### ãªãœåˆ†é›¢ã™ã‚‹ã‹ï¼Ÿ
1. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: lib/ä»¥ä¸‹ã¯Next.jséä¾å­˜ã®ãŸã‚ã€è»½é‡ãªNodeç’°å¢ƒã§é«˜é€Ÿå®Ÿè¡Œ
2. **é©åˆ‡ãªç’°å¢ƒ**: UIãƒ†ã‚¹ãƒˆã¯DOMç’°å¢ƒã€ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã¯ç´”ç²‹ãªNodeç’°å¢ƒ
3. **ä¾å­˜é–¢ä¿‚ã®æ˜ç¢ºåŒ–**: å„å±¤ãŒå¿…è¦ã¨ã™ã‚‹ç’°å¢ƒã‚’æ˜ç¤ºçš„ã«åˆ†é›¢

#### å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰
```bash
npm run test           # ä¸¡ç’°å¢ƒã§å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm run test:node      # Nodeç’°å¢ƒã®ã¿ï¼ˆlib/ï¼‰
npm run test:browser   # Browserç’°å¢ƒã®ã¿ï¼ˆapi/, src/ï¼‰
```

## ğŸ”§ ãƒ¢ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ 

### ts-auto-mock ã¨ Proxy-Based autoMock ã®ä½µç”¨

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯2ã¤ã®ãƒ¢ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ï¼š

#### 1. ts-auto-mock (TypeScript Transformer)
- **ç”¨é€”**: TypeScriptå‹æƒ…å ±ã‹ã‚‰ã®è‡ªå‹•ãƒ¢ãƒƒã‚¯ç”Ÿæˆ
- **è¨­å®š**: jest.config.jsã®transformerã¨ã—ã¦è¨­å®š
- **åˆ©ç‚¹**: å‹å®‰å…¨æ€§ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®ãƒ¢ãƒƒã‚¯ç”Ÿæˆ
- **åˆ¶é™**: Node.jsç’°å¢ƒã§ã¯äº’æ›æ€§ã®å•é¡Œã«ã‚ˆã‚Šæœªä½¿ç”¨

```typescript
// __tests__/fixtures/repositories.fixture.ts
import { createMock } from 'ts-auto-mock'

export const createMockSlackRepository = (): jest.Mocked<SlackRepositoryInterface> =>
  createMock<SlackRepositoryInterface>()
```

#### 2. Proxy-Based autoMock System (ã‚«ã‚¹ã‚¿ãƒ å®Ÿè£…)

**2025å¹´8æœˆ: JavaScript ProxyæŠ€è¡“ã‚’æ´»ç”¨ã—ãŸé©æ–°çš„ãªè‡ªå‹•ãƒ¢ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ ã‚’å°å…¥**

#### autoMockå®Ÿè£…ã®åˆ©ç‚¹
- **ã‚³ãƒ¼ãƒ‰å‰Šæ¸›**: å¾“æ¥ã®æ‰‹å‹•ãƒ¢ãƒƒã‚¯å®Ÿè£…ã‹ã‚‰20-30%ã®ã‚³ãƒ¼ãƒ‰å‰Šæ¸›
- **ä¿å®ˆæ€§å‘ä¸Š**: ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å¤‰æ›´æ™‚ã®è‡ªå‹•è¿½å¾“
- **ä¸€è²«æ€§**: å…¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§çµ±ä¸€ã•ã‚ŒãŸãƒ¢ãƒƒã‚¯ãƒ‘ã‚¿ãƒ¼ãƒ³
- **é–‹ç™ºåŠ¹ç‡**: å˜ä¸€è¡Œã§ã®ãƒ¢ãƒƒã‚¯ä½œæˆãŒå¯èƒ½

#### Proxy-Based autoMock Pattern

```typescript
// __tests__/utils/mockBuilder.ts
export function createAutoMock<T>(): T & MockControlInterface {
  const mockResults: any[] = []
  let callIndex = 0

  const proxy = new Proxy({} as T & MockControlInterface, {
    get(target, prop) {
      if (prop === 'setMockResults') {
        return (results: any[]) => {
          mockResults.length = 0
          mockResults.push(...results)
          callIndex = 0
        }
      }
      
      if (prop === 'getNextResult') {
        return () => {
          if (callIndex >= mockResults.length) {
            throw new Error('No more mock results available')
          }
          return mockResults[callIndex++]
        }
      }
      
      // ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è‡ªå‹•çš„ã«ãƒ¢ãƒƒã‚¯åŒ–
      return jest.fn().mockImplementation(() => {
        return proxy.getNextResult()
      })
    }
  })

  return proxy
}
```

#### Migration Success Examples

**Before: Manual Mock Implementation (606 lines)**
```typescript
class MockNotificationSettingsRepository implements NotificationSettingsRepositoryInterface {
  private results: RepositoryResult<any>[] = []
  private currentIndex = 0

  setResults(results: RepositoryResult<any>[]) {
    this.results = results
    this.currentIndex = 0
  }

  async findByUserId(userId: string): Promise<RepositoryResult<NotificationSettingsEntity | null>> {
    return this.getNextResult()
  }

  async create(settings: NotificationSettingsData): Promise<RepositoryResult<NotificationSettingsEntity>> {
    return this.getNextResult()
  }
  
  // ... 15+ methods with identical implementation
  
  private getNextResult(): RepositoryResult<any> {
    if (this.currentIndex >= this.results.length) {
      throw new Error('No more mock results available')
    }
    return this.results[this.currentIndex++]
  }
}
```

**After: autoMock Implementation (514 lines - 15% reduction)**
```typescript
// Simple one-line mock creation
let mockRepository: NotificationSettingsRepositoryInterface & MockControlInterface

beforeEach(() => {
  mockRepository = createAutoMock<NotificationSettingsRepositoryInterface>()
  service = new NotificationSettingsService(mockRepository)
})

test('should find notification settings by user ID', async () => {
  // Set mock results - all methods automatically available
  mockRepository.setMockResults([
    { success: true, data: createMockNotificationSettingsEntity() }
  ])

  const result = await service.findByUserId('user-123')
  expect(result.success).toBe(true)
})
```

### Result-Based Mocking

å¾“æ¥ã®è¤‡é›‘ãªmockãƒã‚§ãƒ¼ãƒ³ã‚’ç°¡æ½”ãªçµæœãƒ™ãƒ¼ã‚¹ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ç½®ãæ›ãˆï¼š

```typescript
// âœ… Result-Based Approach with autoMock
const mockService = createAutoMock<SlackServiceInterface>()
mockService.setMockResults([
  { success: true, data: result1, statusCode: 200 },
  { success: false, error: 'Not found', statusCode: 404 }
])

// âŒ å¾“æ¥ã®è¤‡é›‘ãªmockãƒã‚§ãƒ¼ãƒ³
jest.fn()
  .mockResolvedValueOnce(mockResult1)
  .mockResolvedValueOnce(mockResult2)
  .mockResolvedValueOnce(mockResult3)
  // ... 30+ sequential mocks
```

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ¢ãƒƒã‚¯

#### Serviceå±¤ãƒ¢ãƒƒã‚¯

```typescript
// __tests__/mocks/services.ts
export class MockSlackService {
  private mockResults: SlackServiceResult<any>[] = []
  private callIndex = 0

  setMockResults(results: SlackServiceResult<any>[]) {
    this.mockResults = results
    this.callIndex = 0
  }

  async processWebhookEvent(
    webhookId: string,
    payload: SlackEventPayload
  ): Promise<SlackServiceResult<WebhookProcessingResult>> {
    return this.getNextResult()
  }

  private getNextResult(): SlackServiceResult<any> {
    if (this.callIndex >= this.mockResults.length) {
      throw new Error(`MockSlackService: No more mock results available (called ${this.callIndex} times)`)
    }
    return this.mockResults[this.callIndex++]
  }
}
```

#### Repositoryå±¤ãƒ¢ãƒƒã‚¯

```typescript
// __tests__/mocks/repositories.ts
export class MockSlackRepository implements SlackRepositoryInterface {
  private mockResults: RepositoryResult<any>[] = []
  private callIndex = 0

  setMockResults(results: RepositoryResult<any>[]) {
    this.mockResults = results
    this.callIndex = 0
  }

  async findWebhookById(webhookId: string): Promise<RepositoryResult<SlackWebhook>> {
    return this.getNextResult()
  }

  async createTodoFromSlackMessage(
    userId: string,
    todoData: Partial<Todo>
  ): Promise<RepositoryResult<Todo>> {
    return this.getNextResult()
  }

  private getNextResult(): RepositoryResult<any> {
    if (this.callIndex >= this.mockResults.length) {
      throw new Error('MockSlackRepository: No more mock results available')
    }
    return this.mockResults[this.callIndex++]
  }
}
```

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ¢ãƒƒã‚¯

#### Use Caseså±¤ãƒ¢ãƒƒã‚¯

```typescript
// __tests__/mocks/use-cases.ts
export class MockTodoUseCases {
  private mockResults: UseCaseResult<any>[] = []
  private callIndex = 0

  setMockResults(results: UseCaseResult<any>[]) {
    this.mockResults = results
    this.callIndex = 0
  }

  async createTodo(params: CreateTodoParams): Promise<UseCaseResult<TodoEntity>> {
    return this.getNextResult()
  }

  async updateTodo(params: UpdateTodoParams): Promise<UseCaseResult<TodoEntity>> {
    return this.getNextResult()
  }

  private getNextResult(): UseCaseResult<any> {
    if (this.callIndex >= this.mockResults.length) {
      throw new Error('MockTodoUseCases: No more mock results available')
    }
    return this.mockResults[this.callIndex++]
  }
}
```

#### Frontend Repositoryå±¤ãƒ¢ãƒƒã‚¯

```typescript
// __tests__/mocks/frontend-repositories.ts
export class MockTodoRepository implements TodoRepositoryInterface {
  private mockResults: RepositoryResult<any>[] = []
  private callIndex = 0

  setMockResults(results: RepositoryResult<any>[]) {
    this.mockResults = results
    this.callIndex = 0
  }

  async findById(id: string): Promise<RepositoryResult<TodoEntity>> {
    return this.getNextResult()
  }

  async create(params: CreateTodoParams): Promise<RepositoryResult<TodoEntity>> {
    return this.getNextResult()
  }

  private getNextResult(): RepositoryResult<any> {
    if (this.callIndex >= this.mockResults.length) {
      throw new Error('MockTodoRepository: No more mock results available')
    }
    return this.mockResults[this.callIndex++]
  }
}
```

## ğŸ§© ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

### Fixtureé–¢æ•°

#### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰Fixture

```typescript
// __tests__/fixtures/entities.ts
export const createMockTodo = (overrides: Partial<Todo> = {}): Todo => ({
  id: 'mock-todo-id',
  user_id: 'mock-user-id',
  title: 'Mock Todo',
  description: 'Mock description',
  deadline: null,
  importance_score: 0.5,
  status: 'open',
  slack_url: null,
  created_via: 'manual',
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString(),
  ...overrides
})

export const createMockSlackPayload = (overrides: Partial<SlackEventPayload> = {}): SlackEventPayload => ({
  type: 'event_callback',
  event: {
    type: 'reaction_added',
    user: 'U1234567890',
    reaction: 'memo',
    item: {
      channel: 'C1234567890',
      ts: '1234567890.123456'
    }
  },
  ...overrides
})
```

#### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰Fixture

```typescript
// __tests__/fixtures/frontend-entities.ts
export const createMockTodoEntity = (overrides: Partial<TodoData> = {}): TodoEntity => {
  const todoData = {
    id: 'mock-todo-id',
    userId: 'mock-user-id',
    title: 'Mock Todo',
    body: 'Mock description',
    deadline: null,
    importanceScore: 0.5,
    status: 'open' as TodoStatus,
    createdVia: 'manual' as TodoCreatedVia,
    createdAt: new Date().toISOString(),
    ...overrides
  }
  return new TodoEntity(todoData)
}

export const createMockUserEntity = (overrides: Partial<UserData> = {}): UserEntity => {
  const userData = {
    id: 'mock-user-id',
    email: 'test@example.com',
    profile: {
      displayName: 'Test User',
      avatarUrl: null
    },
    ...overrides
  }
  return new UserEntity(userData)
}
```

### Helperé–¢æ•°

```typescript
// __tests__/helpers/date-helpers.ts
export const getDateString = (daysFromToday: number): string => {
  const date = new Date()
  date.setDate(date.getDate() + daysFromToday)
  return date.toISOString().split('T')[0]
}

export const getTodayString = (): string => getDateString(0)
export const getTomorrowString = (): string => getDateString(1)
export const getYesterdayString = (): string => getDateString(-1)
```

## ğŸš€ ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

### åŸºæœ¬ã‚³ãƒãƒ³ãƒ‰

```bash
# å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm run test

# ç›£è¦–ãƒ¢ãƒ¼ãƒ‰ã§ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm run test:watch

# ã‚«ãƒãƒ¬ãƒƒã‚¸ä»˜ããƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm run test:coverage

# ç‰¹å®šã®ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿å®Ÿè¡Œ
npm test SlackService.test.ts

# ç‰¹å®šã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®ã¿å®Ÿè¡Œ
npm test -- --testNamePattern="should process valid webhook event"
```

### ãƒ†ã‚¹ãƒˆè¨­å®š

```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/$1'
  },
  collectCoverageFrom: [
    'lib/**/*.{ts,tsx}',
    'app/api/**/*.{ts,tsx}',
    '!**/*.d.ts',
    '!**/node_modules/**'
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70
    }
  }
}
```

## ğŸ“Š ã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰

#### Serviceå±¤
- **é–¢æ•°ã‚«ãƒãƒ¬ãƒƒã‚¸**: 90%ä»¥ä¸Š
- **ãƒ–ãƒ©ãƒ³ãƒã‚«ãƒãƒ¬ãƒƒã‚¸**: 85%ä»¥ä¸Š
- **è¡Œã‚«ãƒãƒ¬ãƒƒã‚¸**: 90%ä»¥ä¸Š

#### Repositoryå±¤
- **é–¢æ•°ã‚«ãƒãƒ¬ãƒƒã‚¸**: 80%ä»¥ä¸Š
- **ãƒ–ãƒ©ãƒ³ãƒã‚«ãƒãƒ¬ãƒƒã‚¸**: 75%ä»¥ä¸Š
- **è¡Œã‚«ãƒãƒ¬ãƒƒã‚¸**: 80%ä»¥ä¸Š

#### Entityå±¤
- **é–¢æ•°ã‚«ãƒãƒ¬ãƒƒã‚¸**: 95%ä»¥ä¸Š
- **ãƒ–ãƒ©ãƒ³ãƒã‚«ãƒãƒ¬ãƒƒã‚¸**: 90%ä»¥ä¸Š
- **è¡Œã‚«ãƒãƒ¬ãƒƒã‚¸**: 95%ä»¥ä¸Š

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰

#### Use Caseså±¤
- **é–¢æ•°ã‚«ãƒãƒ¬ãƒƒã‚¸**: 90%ä»¥ä¸Š
- **ãƒ–ãƒ©ãƒ³ãƒã‚«ãƒãƒ¬ãƒƒã‚¸**: 85%ä»¥ä¸Š
- **è¡Œã‚«ãƒãƒ¬ãƒƒã‚¸**: 90%ä»¥ä¸Š

#### Repositoryå±¤
- **é–¢æ•°ã‚«ãƒãƒ¬ãƒƒã‚¸**: 85%ä»¥ä¸Š
- **ãƒ–ãƒ©ãƒ³ãƒã‚«ãƒãƒ¬ãƒƒã‚¸**: 80%ä»¥ä¸Š
- **è¡Œã‚«ãƒãƒ¬ãƒƒã‚¸**: 85%ä»¥ä¸Š

#### Entityå±¤
- **é–¢æ•°ã‚«ãƒãƒ¬ãƒƒã‚¸**: 95%ä»¥ä¸Š
- **ãƒ–ãƒ©ãƒ³ãƒã‚«ãƒãƒ¬ãƒƒã‚¸**: 90%ä»¥ä¸Š
- **è¡Œã‚«ãƒãƒ¬ãƒƒã‚¸**: 95%ä»¥ä¸Š

#### Presentationå±¤ï¼ˆã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ï¼‰
- **é–¢æ•°ã‚«ãƒãƒ¬ãƒƒã‚¸**: 80%ä»¥ä¸Š
- **ãƒ–ãƒ©ãƒ³ãƒã‚«ãƒãƒ¬ãƒƒã‚¸**: 75%ä»¥ä¸Š
- **è¡Œã‚«ãƒãƒ¬ãƒƒã‚¸**: 80%ä»¥ä¸Š

## ğŸ› ãƒ†ã‚¹ãƒˆãƒ‡ãƒãƒƒã‚°

### ä¸€èˆ¬çš„ãªãƒ†ã‚¹ãƒˆå¤±æ•—ã®åŸå› 

1. **Dateãƒ»Timeé–¢é€£**
   ```typescript
   // âŒ ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã®å•é¡Œ
   expect(todo.isUrgent()).toBe(true)  // ç¾åœ°æ™‚é–“ä¾å­˜
   
   // âœ… å›ºå®šã®æ—¥ä»˜ã‚’ä½¿ç”¨
   const mockDate = '2025-01-01'
   const todo = createMockTodo({ deadline: mockDate })
   ```

2. **éåŒæœŸå‡¦ç†**
   ```typescript
   // âŒ awaitã‚’å¿˜ã‚Œã‚‹
   const result = slackService.processWebhookEvent(webhookId, payload)
   
   // âœ… é©åˆ‡ãªéåŒæœŸå‡¦ç†
   const result = await slackService.processWebhookEvent(webhookId, payload)
   ```

3. **Mockè¨­å®šã®ä¸å‚™**
   ```typescript
   // âŒ MockçµæœãŒä¸è¶³
   mockService.setMockResults([result1])
   await service.methodThatCallsTwice()  // ã‚¨ãƒ©ãƒ¼
   
   // âœ… ååˆ†ãªMockçµæœã‚’ç”¨æ„
   mockService.setMockResults([result1, result2])
   ```

### ãƒ‡ãƒãƒƒã‚°æ–¹æ³•

```typescript
// ãƒ†ã‚¹ãƒˆä¸­ã®ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›
describe('SlackService', () => {
  test('debug test', async () => {
    console.log('Test input:', { webhookId, payload })
    
    const result = await slackService.processWebhookEvent(webhookId, payload)
    
    console.log('Test result:', result)
    expect(result.success).toBe(true)
  })
})
```

## ğŸ” ãƒ†ã‚¹ãƒˆãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### Arrange-Act-Assert ãƒ‘ã‚¿ãƒ¼ãƒ³

```typescript
test('should create todo from slack message', async () => {
  // Arrange - ãƒ†ã‚¹ãƒˆã®æº–å‚™
  const webhookId = 'test-webhook-id'
  const payload = createMockSlackPayload()
  mockSlackRepo.setMockResults([validWebhookResult])
  
  // Act - ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®å®Ÿè¡Œ
  const result = await slackService.processWebhookEvent(webhookId, payload)
  
  // Assert - çµæœã®æ¤œè¨¼
  expect(result.success).toBe(true)
  expect(result.data.todo).toBeDefined()
})
```

### é©åˆ‡ãªãƒ†ã‚¹ãƒˆå

```typescript
// âœ… è‰¯ã„ãƒ†ã‚¹ãƒˆå
test('should return 404 when webhook not found')
test('should create todo with correct urgency for memo emoji')
test('should reject event from non-connected user')

// âŒ æ‚ªã„ãƒ†ã‚¹ãƒˆå
test('webhook test')
test('it works')
test('test1')
```

### ãƒ†ã‚¹ãƒˆã®ç‹¬ç«‹æ€§

```typescript
// âœ… å„ãƒ†ã‚¹ãƒˆã§æ–°ã—ã„ãƒ¢ãƒƒã‚¯ã‚’ä½œæˆ
beforeEach(() => {
  mockSlackRepo = new MockSlackRepository()
  mockTodoRepo = new MockTodoRepository()
  slackService = new SlackService(mockSlackRepo, mockTodoRepo)
})

// âŒ ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªãƒ¢ãƒƒã‚¯ã®å†åˆ©ç”¨
let globalMockService = new MockSlackService()  // å±é™º
```

## ğŸ“‹ ç¶™ç¶šçš„ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

### CI/CDã§ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

```yaml
# .github/workflows/test.yml
name: Tests
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run lint
      - run: npm run test:coverage
      - run: npm run build
```

### ãƒ†ã‚¹ãƒˆå ±å‘Š

```bash
# ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
npm run test:coverage

# CIç’°å¢ƒã§ã®ãƒ†ã‚¹ãƒˆçµæœå‡ºåŠ›
npm run test -- --ci --coverage --watchAll=false
```

## ğŸ“š é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [é–‹ç™ºã‚¬ã‚¤ãƒ‰](./DEVELOPMENT.md) - é–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹ã¨ãƒ«ãƒ¼ãƒ«
- [ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¬ã‚¤ãƒ‰](./SECURITY.md) - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
- [ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦](../architecture/ARCHITECTURE.md) - ãƒ†ã‚¹ãƒˆå¯èƒ½ãªè¨­è¨ˆ
- [APIä»•æ§˜](../architecture/API.md) - APIãƒ†ã‚¹ãƒˆã®è©³ç´°